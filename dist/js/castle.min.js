(function () {
  'use strict';

  // packages/ui/src/list-context.js
  function generateContext(Alpine2, multiple, orientation, activateSelectedOrFirst) {
    return {
      /**
       * Main state...
       */
      items: [],
      activeKey: switchboard(),
      orderedKeys: [],
      activatedByKeyPress: false,
      /**
       *  Initialization...
       */
      activateSelectedOrFirst: Alpine2.debounce(function() {
        activateSelectedOrFirst(false);
      }),
      registerItemsQueue: [],
      registerItem(key, el, value, disabled) {
        if (this.registerItemsQueue.length === 0) {
          queueMicrotask(() => {
            if (this.registerItemsQueue.length > 0) {
              this.items = this.items.concat(this.registerItemsQueue);
              this.registerItemsQueue = [];
              this.reorderKeys();
              this.activateSelectedOrFirst();
            }
          });
        }
        let item = {
          key,
          el,
          value,
          disabled
        };
        this.registerItemsQueue.push(item);
      },
      unregisterKeysQueue: [],
      unregisterItem(key) {
        if (this.unregisterKeysQueue.length === 0) {
          queueMicrotask(() => {
            if (this.unregisterKeysQueue.length > 0) {
              this.items = this.items.filter((i) => !this.unregisterKeysQueue.includes(i.key));
              this.orderedKeys = this.orderedKeys.filter((i) => !this.unregisterKeysQueue.includes(i));
              this.unregisterKeysQueue = [];
              this.reorderKeys();
              this.activateSelectedOrFirst();
            }
          });
        }
        this.unregisterKeysQueue.push(key);
      },
      getItemByKey(key) {
        return this.items.find((i) => i.key === key);
      },
      getItemByValue(value) {
        return this.items.find((i) => Alpine2.raw(i.value) === Alpine2.raw(value));
      },
      getItemByEl(el) {
        return this.items.find((i) => i.el === el);
      },
      getItemsByValues(values) {
        let rawValues = values.map((i) => Alpine2.raw(i));
        let filteredValue = this.items.filter((i) => rawValues.includes(Alpine2.raw(i.value)));
        filteredValue = filteredValue.slice().sort((a, b) => {
          let position = a.el.compareDocumentPosition(b.el);
          if (position & Node.DOCUMENT_POSITION_FOLLOWING)
            return -1;
          if (position & Node.DOCUMENT_POSITION_PRECEDING)
            return 1;
          return 0;
        });
        return filteredValue;
      },
      getActiveItem() {
        if (!this.hasActive())
          return null;
        let item = this.items.find((i) => i.key === this.activeKey.get());
        if (!item)
          this.deactivateKey(this.activeKey.get());
        return item;
      },
      activateItem(item) {
        if (!item)
          return;
        this.activateKey(item.key);
      },
      /**
       * Handle elements...
       */
      reorderKeys: Alpine2.debounce(function() {
        this.orderedKeys = this.items.map((i) => i.key);
        this.orderedKeys = this.orderedKeys.slice().sort((a, z) => {
          if (a === null || z === null)
            return 0;
          let aEl = this.items.find((i) => i.key === a).el;
          let zEl = this.items.find((i) => i.key === z).el;
          let position = aEl.compareDocumentPosition(zEl);
          if (position & Node.DOCUMENT_POSITION_FOLLOWING)
            return -1;
          if (position & Node.DOCUMENT_POSITION_PRECEDING)
            return 1;
          return 0;
        });
        if (!this.orderedKeys.includes(this.activeKey.get()))
          this.deactivateKey(this.activeKey.get());
      }),
      getActiveKey() {
        return this.activeKey.get();
      },
      activeEl() {
        if (!this.activeKey.get())
          return;
        return this.items.find((i) => i.key === this.activeKey.get()).el;
      },
      isActiveEl(el) {
        let key = this.items.find((i) => i.el === el);
        return this.activeKey.is(key);
      },
      activateEl(el) {
        let item = this.items.find((i) => i.el === el);
        this.activateKey(item.key);
      },
      isDisabledEl(el) {
        return this.items.find((i) => i.el === el).disabled;
      },
      get isScrollingTo() {
        return this.scrollingCount > 0;
      },
      scrollingCount: 0,
      activateAndScrollToKey(key, activatedByKeyPress) {
        if (!this.getItemByKey(key))
          return;
        this.scrollingCount++;
        this.activateKey(key, activatedByKeyPress);
        let targetEl = this.items.find((i) => i.key === key).el;
        targetEl.scrollIntoView({ block: "nearest" });
        setTimeout(() => {
          this.scrollingCount--;
        }, 25);
      },
      /**
       * Handle disabled keys...
       */
      isDisabled(key) {
        let item = this.items.find((i) => i.key === key);
        if (!item)
          return false;
        return item.disabled;
      },
      get nonDisabledOrderedKeys() {
        return this.orderedKeys.filter((i) => !this.isDisabled(i));
      },
      /**
       * Handle activated keys...
       */
      hasActive() {
        return !!this.activeKey.get();
      },
      /**
       * Return true if the latest active element was activated
       * by the user (i.e. using the arrow keys) and false if was
       * activated automatically by alpine (i.e. first element automatically
       * activated after filtering the list)
       */
      wasActivatedByKeyPress() {
        return this.activatedByKeyPress;
      },
      isActiveKey(key) {
        return this.activeKey.is(key);
      },
      activateKey(key, activatedByKeyPress = false) {
        if (this.isDisabled(key))
          return;
        this.activeKey.set(key);
        this.activatedByKeyPress = activatedByKeyPress;
      },
      deactivateKey(key) {
        if (this.activeKey.get() === key) {
          this.activeKey.set(null);
          this.activatedByKeyPress = false;
        }
      },
      deactivate() {
        if (!this.activeKey.get())
          return;
        if (this.isScrollingTo)
          return;
        this.activeKey.set(null);
        this.activatedByKeyPress = false;
      },
      /**
       * Handle active key traversal...
       */
      nextKey() {
        if (!this.activeKey.get())
          return;
        let index = this.nonDisabledOrderedKeys.findIndex((i) => i === this.activeKey.get());
        return this.nonDisabledOrderedKeys[index + 1];
      },
      prevKey() {
        if (!this.activeKey.get())
          return;
        let index = this.nonDisabledOrderedKeys.findIndex((i) => i === this.activeKey.get());
        return this.nonDisabledOrderedKeys[index - 1];
      },
      firstKey() {
        return this.nonDisabledOrderedKeys[0];
      },
      lastKey() {
        return this.nonDisabledOrderedKeys[this.nonDisabledOrderedKeys.length - 1];
      },
      searchQuery: "",
      clearSearch: Alpine2.debounce(function() {
        this.searchQuery = "";
      }, 350),
      searchKey(query) {
        this.clearSearch();
        this.searchQuery += query;
        let foundKey;
        for (let key in this.items) {
          let content = this.items[key].el.textContent.trim().toLowerCase();
          if (content.startsWith(this.searchQuery)) {
            foundKey = this.items[key].key;
            break;
          }
        }
        if (!this.nonDisabledOrderedKeys.includes(foundKey))
          return;
        return foundKey;
      },
      activateByKeyEvent(e, searchable = false, isOpen = () => false, open = () => {
      }, setIsTyping) {
        let targetKey, hasActive;
        setIsTyping(true);
        let activatedByKeyPress = true;
        switch (e.key) {
          case ["ArrowDown", "ArrowRight"][orientation === "vertical" ? 0 : 1]:
            e.preventDefault();
            e.stopPropagation();
            setIsTyping(false);
            if (!isOpen()) {
              open();
              break;
            }
            this.reorderKeys();
            hasActive = this.hasActive();
            targetKey = hasActive ? this.nextKey() : this.firstKey();
            break;
          case ["ArrowUp", "ArrowLeft"][orientation === "vertical" ? 0 : 1]:
            e.preventDefault();
            e.stopPropagation();
            setIsTyping(false);
            if (!isOpen()) {
              open();
              break;
            }
            this.reorderKeys();
            hasActive = this.hasActive();
            targetKey = hasActive ? this.prevKey() : this.lastKey();
            break;
          case "Home":
          case "PageUp":
            if (e.key == "Home" && e.shiftKey)
              return;
            e.preventDefault();
            e.stopPropagation();
            setIsTyping(false);
            this.reorderKeys();
            hasActive = this.hasActive();
            targetKey = this.firstKey();
            break;
          case "End":
          case "PageDown":
            if (e.key == "End" && e.shiftKey)
              return;
            e.preventDefault();
            e.stopPropagation();
            setIsTyping(false);
            this.reorderKeys();
            hasActive = this.hasActive();
            targetKey = this.lastKey();
            break;
          default:
            activatedByKeyPress = this.activatedByKeyPress;
            if (searchable && e.key.length === 1) {
              targetKey = this.searchKey(e.key);
            }
            break;
        }
        if (targetKey) {
          this.activateAndScrollToKey(targetKey, activatedByKeyPress);
        }
      }
    };
  }
  function renderHiddenInputs(Alpine2, el, name, value) {
    let newInputs = generateInputs(name, value);
    newInputs.forEach((i) => i._x_hiddenInput = true);
    newInputs.forEach((i) => i._x_ignore = true);
    let children = el.children;
    let oldInputs = [];
    for (let i = 0; i < children.length; i++) {
      let child = children[i];
      if (child._x_hiddenInput)
        oldInputs.push(child);
      else
        break;
    }
    Alpine2.mutateDom(() => {
      oldInputs.forEach((i) => i.remove());
      newInputs.reverse().forEach((i) => el.prepend(i));
    });
  }
  function generateInputs(name, value, carry = []) {
    if (isObjectOrArray(value)) {
      for (let key in value) {
        carry = carry.concat(
          generateInputs(`${name}[${key}]`, value[key])
        );
      }
    } else {
      let el = document.createElement("input");
      el.setAttribute("type", "hidden");
      el.setAttribute("name", name);
      el.setAttribute("value", "" + value);
      return [el];
    }
    return carry;
  }
  function isObjectOrArray(subject) {
    return typeof subject === "object" && subject !== null;
  }
  function switchboard(value) {
    let lookup = {};
    let current;
    let changeTracker = Alpine.reactive({ state: false });
    let get = () => {
      if (changeTracker.state) ;
      return current;
    };
    let set = (newValue) => {
      if (newValue === current)
        return;
      if (current !== void 0)
        lookup[current].state = false;
      current = newValue;
      if (lookup[newValue] === void 0) {
        lookup[newValue] = Alpine.reactive({ state: true });
      } else {
        lookup[newValue].state = true;
      }
      changeTracker.state = !changeTracker.state;
    };
    let is = (comparisonValue) => {
      if (lookup[comparisonValue] === void 0) {
        lookup[comparisonValue] = Alpine.reactive({ state: false });
        return lookup[comparisonValue].state;
      }
      return !!lookup[comparisonValue].state;
    };
    value === void 0 || set(value);
    return { get, set, is };
  }

  // packages/ui/src/combobox.js
  function combobox_default(Alpine2) {
    Alpine2.directive("combobox", (el, directive, { evaluate }) => {
      if (directive.value === "input")
        handleInput(el, Alpine2);
      else if (directive.value === "button")
        handleButton(el, Alpine2);
      else if (directive.value === "label")
        handleLabel(el, Alpine2);
      else if (directive.value === "options")
        handleOptions(el, Alpine2);
      else if (directive.value === "option")
        handleOption(el, Alpine2);
      else
        handleRoot(el, Alpine2);
    }).before("bind");
    Alpine2.magic("combobox", (el) => {
      let data = Alpine2.$data(el);
      return {
        get value() {
          return data.__value;
        },
        get isOpen() {
          return data.__isOpen;
        },
        get isDisabled() {
          return data.__isDisabled;
        },
        get activeOption() {
          let active = data.__context?.getActiveItem();
          return active && active.value;
        },
        get activeIndex() {
          let active = data.__context?.getActiveItem();
          if (active) {
            return Object.values(Alpine2.raw(data.__context.items)).findIndex((i) => Alpine2.raw(active) == Alpine2.raw(i));
          }
          return null;
        }
      };
    });
    Alpine2.magic("comboboxOption", (el) => {
      let data = Alpine2.$data(el);
      let optionEl = Alpine2.findClosest(el, (i) => {
        return i.hasAttribute("x-combobox:option");
      });
      if (!optionEl)
        throw "No x-combobox:option directive found...";
      return {
        get isActive() {
          return data.__context.isActiveKey(Alpine2.$data(optionEl).__optionKey);
        },
        get isSelected() {
          return data.__isSelected(optionEl);
        },
        get isDisabled() {
          return data.__context.isDisabled(Alpine2.$data(optionEl).__optionKey);
        }
      };
    });
  }
  function handleRoot(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-id"() {
        return ["alpine-combobox-button", "alpine-combobox-options", "alpine-combobox-label"];
      },
      "x-modelable": "__value",
      // Initialize...
      "x-data"() {
        return {
          /**
           * Combobox state...
           */
          __ready: false,
          __value: null,
          __isOpen: false,
          __context: void 0,
          __isMultiple: void 0,
          __isStatic: false,
          __isDisabled: void 0,
          __displayValue: void 0,
          __compareBy: null,
          __inputName: null,
          __isTyping: false,
          __hold: false,
          /**
           * Combobox initialization...
           */
          init() {
            this.__isMultiple = Alpine2.extractProp(el, "multiple", false);
            this.__isDisabled = Alpine2.extractProp(el, "disabled", false);
            this.__inputName = Alpine2.extractProp(el, "name", null);
            this.__nullable = Alpine2.extractProp(el, "nullable", false);
            this.__compareBy = Alpine2.extractProp(el, "by");
            this.__context = generateContext(Alpine2, this.__isMultiple, "vertical", () => this.__activateSelectedOrFirst());
            let defaultValue = Alpine2.extractProp(el, "default-value", this.__isMultiple ? [] : null);
            this.__value = defaultValue;
            queueMicrotask(() => {
              Alpine2.effect(() => {
                this.__inputName && renderHiddenInputs(Alpine2, this.$el, this.__inputName, this.__value);
              });
              Alpine2.effect(() => !this.__isMultiple && this.__resetInput());
            });
          },
          __startTyping() {
            this.__isTyping = true;
          },
          __stopTyping() {
            this.__isTyping = false;
          },
          __resetInput() {
            let input = this.$refs.__input;
            if (!input)
              return;
            let value = this.__getCurrentValue();
            input.value = value;
          },
          __getCurrentValue() {
            if (!this.$refs.__input)
              return "";
            if (!this.__value)
              return "";
            if (this.__displayValue)
              return this.__displayValue(this.__value);
            if (typeof this.__value === "string")
              return this.__value;
            return "";
          },
          __open() {
            if (this.__isOpen)
              return;
            this.__isOpen = true;
            let input = this.$refs.__input;
            if (input) {
              let value = input.value;
              let { selectionStart, selectionEnd, selectionDirection } = input;
              input.value = "";
              input.dispatchEvent(new Event("change"));
              input.value = value;
              if (selectionDirection !== null) {
                input.setSelectionRange(selectionStart, selectionEnd, selectionDirection);
              } else {
                input.setSelectionRange(selectionStart, selectionEnd);
              }
            }
            let nextTick = (callback) => requestAnimationFrame(() => requestAnimationFrame(callback));
            nextTick(() => {
              this.$refs.__input.focus({ preventScroll: true });
              this.__activateSelectedOrFirst();
            });
          },
          __close() {
            this.__isOpen = false;
            this.__context.deactivate();
          },
          __activateSelectedOrFirst(activateSelected = true) {
            if (!this.__isOpen)
              return;
            if (this.__context.hasActive() && this.__context.wasActivatedByKeyPress())
              return;
            let firstSelectedValue;
            if (this.__isMultiple) {
              let selectedItem = this.__context.getItemsByValues(this.__value);
              firstSelectedValue = selectedItem.length ? selectedItem[0].value : null;
            } else {
              firstSelectedValue = this.__value;
            }
            let firstSelected = null;
            if (activateSelected && firstSelectedValue) {
              firstSelected = this.__context.getItemByValue(firstSelectedValue);
            }
            if (firstSelected) {
              this.__context.activateAndScrollToKey(firstSelected.key);
              return;
            }
            this.__context.activateAndScrollToKey(this.__context.firstKey());
          },
          __selectActive() {
            let active = this.__context.getActiveItem();
            if (active)
              this.__toggleSelected(active.value);
          },
          __selectOption(el2) {
            let item = this.__context.getItemByEl(el2);
            if (item)
              this.__toggleSelected(item.value);
          },
          __isSelected(el2) {
            let item = this.__context.getItemByEl(el2);
            if (!item)
              return false;
            if (!item.value)
              return false;
            return this.__hasSelected(item.value);
          },
          __toggleSelected(value) {
            if (!this.__isMultiple) {
              this.__value = value;
              return;
            }
            let index = this.__value.findIndex((j) => this.__compare(j, value));
            if (index === -1) {
              this.__value.push(value);
            } else {
              this.__value.splice(index, 1);
            }
          },
          __hasSelected(value) {
            if (!this.__isMultiple)
              return this.__compare(this.__value, value);
            return this.__value.some((i) => this.__compare(i, value));
          },
          __compare(a, b) {
            let by = this.__compareBy;
            if (!by)
              by = (a2, b2) => Alpine2.raw(a2) === Alpine2.raw(b2);
            if (typeof by === "string") {
              let property = by;
              by = (a2, b2) => {
                if (!a2 || typeof a2 !== "object" || (!b2 || typeof b2 !== "object")) {
                  return Alpine2.raw(a2) === Alpine2.raw(b2);
                }
                return a2[property] === b2[property];
              };
            }
            return by(a, b);
          }
        };
      },
      // Register event listeners..
      "@mousedown.window"(e) {
        if (!!!this.$refs.__input.contains(e.target) && !this.$refs.__button.contains(e.target) && !this.$refs.__options.contains(e.target)) {
          this.__close();
          this.__resetInput();
        }
      }
    });
  }
  function handleInput(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-ref": "__input",
      ":id"() {
        return this.$id("alpine-combobox-input");
      },
      // Accessibility attributes...
      "role": "combobox",
      "tabindex": "0",
      "aria-autocomplete": "list",
      // We need to defer this evaluation a bit because $refs that get declared later
      // in the DOM aren't available yet when x-ref is the result of an Alpine.bind object.
      async ":aria-controls"() {
        return await microtask(() => this.$refs.__options && this.$refs.__options.id);
      },
      ":aria-expanded"() {
        return this.$data.__isDisabled ? void 0 : this.$data.__isOpen;
      },
      ":aria-multiselectable"() {
        return this.$data.__isMultiple ? true : void 0;
      },
      ":aria-activedescendant"() {
        if (!this.$data.__context.hasActive())
          return;
        let active = this.$data.__context.getActiveItem();
        return active ? active.el.id : null;
      },
      ":aria-labelledby"() {
        return this.$refs.__label ? this.$refs.__label.id : this.$refs.__button ? this.$refs.__button.id : null;
      },
      // Initialize...
      "x-init"() {
        let displayValueFn = Alpine2.extractProp(this.$el, "display-value");
        if (displayValueFn)
          this.$data.__displayValue = displayValueFn;
      },
      // Register listeners...
      "@input.stop"(e) {
        if (this.$data.__isTyping) {
          this.$data.__open();
          this.$dispatch("change");
        }
      },
      "@blur"() {
        this.$data.__stopTyping(false);
      },
      "@keydown"(e) {
        queueMicrotask(() => this.$data.__context.activateByKeyEvent(e, false, () => this.$data.__isOpen, () => this.$data.__open(), (state) => this.$data.__isTyping = state));
      },
      "@keydown.enter.prevent.stop"() {
        this.$data.__selectActive();
        this.$data.__stopTyping();
        if (!this.$data.__isMultiple) {
          this.$data.__close();
          this.$data.__resetInput();
        }
      },
      "@keydown.escape.prevent"(e) {
        if (!this.$data.__static)
          e.stopPropagation();
        this.$data.__stopTyping();
        this.$data.__close();
        this.$data.__resetInput();
      },
      "@keydown.tab"() {
        this.$data.__stopTyping();
        if (this.$data.__isOpen) {
          this.$data.__close();
        }
        this.$data.__resetInput();
      },
      "@keydown.backspace"(e) {
        if (this.$data.__isMultiple)
          return;
        if (!this.$data.__nullable)
          return;
        let input = e.target;
        requestAnimationFrame(() => {
          if (input.value === "") {
            this.$data.__value = null;
            let options = this.$refs.__options;
            if (options) {
              options.scrollTop = 0;
            }
            this.$data.__context.deactivate();
          }
        });
      }
    });
  }
  function handleButton(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-ref": "__button",
      ":id"() {
        return this.$id("alpine-combobox-button");
      },
      // Accessibility attributes...
      "aria-haspopup": "true",
      // We need to defer this evaluation a bit because $refs that get declared later
      // in the DOM aren't available yet when x-ref is the result of an Alpine.bind object.
      async ":aria-controls"() {
        return await microtask(() => this.$refs.__options && this.$refs.__options.id);
      },
      ":aria-labelledby"() {
        return this.$refs.__label ? [this.$refs.__label.id, this.$el.id].join(" ") : null;
      },
      ":aria-expanded"() {
        return this.$data.__isDisabled ? null : this.$data.__isOpen;
      },
      ":disabled"() {
        return this.$data.__isDisabled;
      },
      "tabindex": "-1",
      // Initialize....
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
      },
      // Register listeners...
      "@click"(e) {
        if (this.$data.__isDisabled)
          return;
        if (this.$data.__isOpen) {
          this.$data.__close();
          this.$data.__resetInput();
        } else {
          e.preventDefault();
          this.$data.__open();
        }
        this.$nextTick(() => this.$refs.__input.focus({ preventScroll: true }));
      }
    });
  }
  function handleLabel(el, Alpine2) {
    Alpine2.bind(el, {
      "x-ref": "__label",
      ":id"() {
        return this.$id("alpine-combobox-label");
      },
      "@click"() {
        this.$refs.__input.focus({ preventScroll: true });
      }
    });
  }
  function handleOptions(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-ref": "__options",
      ":id"() {
        return this.$id("alpine-combobox-options");
      },
      // Accessibility attributes...
      "role": "listbox",
      ":aria-labelledby"() {
        return this.$refs.__label ? this.$refs.__label.id : this.$refs.__button ? this.$refs.__button.id : null;
      },
      // Initialize...
      "x-init"() {
        this.$data.__isStatic = Alpine2.bound(this.$el, "static", false);
        if (Alpine2.bound(this.$el, "hold")) {
          this.$data.__hold = true;
        }
      },
      "x-show"() {
        return this.$data.__isStatic ? true : this.$data.__isOpen;
      }
    });
  }
  function handleOption(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-id"() {
        return ["alpine-combobox-option"];
      },
      ":id"() {
        return this.$id("alpine-combobox-option");
      },
      // Accessibility attributes...
      "role": "option",
      ":tabindex"() {
        return this.$comboboxOption.isDisabled ? void 0 : "-1";
      },
      // Only the active element should have aria-selected="true"...
      "x-effect"() {
        this.$comboboxOption.isSelected ? el.setAttribute("aria-selected", true) : el.setAttribute("aria-selected", false);
      },
      ":aria-disabled"() {
        return this.$comboboxOption.isDisabled;
      },
      // Initialize...
      "x-data"() {
        return {
          "__optionKey": null,
          init() {
            this.__optionKey = (Math.random() + 1).toString(36).substring(7);
            let value = Alpine2.extractProp(this.$el, "value");
            let disabled = Alpine2.extractProp(this.$el, "disabled", false, false);
            this.__context.registerItem(this.__optionKey, this.$el, value, disabled);
          },
          destroy() {
            this.__context.unregisterItem(this.__optionKey);
          }
        };
      },
      // Register listeners...
      "@click"() {
        if (this.$comboboxOption.isDisabled)
          return;
        this.__selectOption(this.$el);
        if (!this.__isMultiple) {
          this.__close();
          this.__resetInput();
        }
        this.$nextTick(() => this.$refs.__input.focus({ preventScroll: true }));
      },
      "@mouseenter"(e) {
        this.__context.activateEl(this.$el);
      },
      "@mousemove"(e) {
        if (this.__context.isActiveEl(this.$el))
          return;
        this.__context.activateEl(this.$el);
      },
      "@mouseleave"(e) {
        if (this.__hold)
          return;
        this.__context.deactivate();
      }
    });
  }
  function microtask(callback) {
    return new Promise((resolve) => queueMicrotask(() => resolve(callback())));
  }

  // packages/ui/src/dialog.js
  function dialog_default(Alpine2) {
    Alpine2.directive("dialog", (el, directive) => {
      if (directive.value === "overlay")
        handleOverlay(el, Alpine2);
      else if (directive.value === "panel")
        handlePanel(el, Alpine2);
      else if (directive.value === "title")
        handleTitle(el, Alpine2);
      else if (directive.value === "description")
        handleDescription(el, Alpine2);
      else
        handleRoot2(el, Alpine2);
    });
    Alpine2.magic("dialog", (el) => {
      let $data = Alpine2.$data(el);
      return {
        // Kept here for legacy. Remove after out of beta.
        get open() {
          return $data.__isOpen;
        },
        get isOpen() {
          return $data.__isOpen;
        },
        close() {
          $data.__close();
        }
      };
    });
  }
  function handleRoot2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-data"() {
        return {
          init() {
            Alpine2.bound(el, "open") !== void 0 && Alpine2.effect(() => {
              this.__isOpenState = Alpine2.bound(el, "open");
            });
            if (Alpine2.bound(el, "initial-focus") !== void 0)
              this.$watch("__isOpenState", () => {
                if (!this.__isOpenState)
                  return;
                setTimeout(() => {
                  Alpine2.bound(el, "initial-focus").focus();
                }, 0);
              });
          },
          __isOpenState: false,
          __close() {
            if (Alpine2.bound(el, "open"))
              this.$dispatch("close");
            else
              this.__isOpenState = false;
          },
          get __isOpen() {
            return Alpine2.bound(el, "static", this.__isOpenState);
          }
        };
      },
      "x-modelable": "__isOpenState",
      "x-id"() {
        return ["alpine-dialog-title", "alpine-dialog-description"];
      },
      "x-show"() {
        return this.__isOpen;
      },
      "x-trap.inert.noscroll"() {
        return this.__isOpen;
      },
      "@keydown.escape"() {
        this.__close();
      },
      ":aria-labelledby"() {
        return this.$id("alpine-dialog-title");
      },
      ":aria-describedby"() {
        return this.$id("alpine-dialog-description");
      },
      "role": "dialog",
      "aria-modal": "true"
    });
  }
  function handleOverlay(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        if (this.$data.__isOpen === void 0)
          console.warn('"x-dialog:overlay" is missing a parent element with "x-dialog".');
      },
      "x-show"() {
        return this.__isOpen;
      },
      "@click.prevent.stop"() {
        this.$data.__close();
      }
    });
  }
  function handlePanel(el, Alpine2) {
    Alpine2.bind(el, {
      "@click.outside"() {
        this.$data.__close();
      },
      "x-show"() {
        return this.$data.__isOpen;
      }
    });
  }
  function handleTitle(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        if (this.$data.__isOpen === void 0)
          console.warn('"x-dialog:title" is missing a parent element with "x-dialog".');
      },
      ":id"() {
        return this.$id("alpine-dialog-title");
      }
    });
  }
  function handleDescription(el, Alpine2) {
    Alpine2.bind(el, {
      ":id"() {
        return this.$id("alpine-dialog-description");
      }
    });
  }

  // packages/ui/src/disclosure.js
  function disclosure_default(Alpine2) {
    Alpine2.directive("disclosure", (el, directive) => {
      if (!directive.value)
        handleRoot3(el, Alpine2);
      else if (directive.value === "panel")
        handlePanel2(el, Alpine2);
      else if (directive.value === "button")
        handleButton2(el, Alpine2);
    }).before("bind");
    Alpine2.magic("disclosure", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isOpen() {
          return $data.__isOpen;
        },
        close() {
          $data.__close();
        }
      };
    });
  }
  function handleRoot3(el, Alpine2) {
    Alpine2.bind(el, {
      "x-modelable": "__isOpen",
      "x-data"() {
        return {
          // The panel will call this...
          // We can't do this inside a microtask in x-init because, when default-open is set to "true",
          // It will cause the panel to transition in for the first time, instead of showing instantly...
          __determineDefaultOpenState() {
            let defaultIsOpen = Boolean(Alpine2.bound(this.$el, "default-open", false));
            if (defaultIsOpen)
              this.__isOpen = defaultIsOpen;
          },
          __isOpen: false,
          __close() {
            this.__isOpen = false;
          },
          __toggle() {
            this.__isOpen = !this.__isOpen;
          }
        };
      },
      "x-id"() {
        return ["alpine-disclosure-panel"];
      }
    });
  }
  function handleButton2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
      },
      "@click"() {
        this.$data.__isOpen = !this.$data.__isOpen;
      },
      ":aria-expanded"() {
        return this.$data.__isOpen;
      },
      ":aria-controls"() {
        return this.$data.$id("alpine-disclosure-panel");
      },
      "@keydown.space.prevent.stop"() {
        this.$data.__toggle();
      },
      "@keydown.enter.prevent.stop"() {
        this.$data.__toggle();
      },
      // Required for firefox, event.preventDefault() in handleKeyDown for
      // the Space key doesn't cancel the handleKeyUp, which in turn
      // triggers a *click*.
      "@keyup.space.prevent"() {
      }
    });
  }
  function handlePanel2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__determineDefaultOpenState();
      },
      "x-show"() {
        return this.$data.__isOpen;
      },
      ":id"() {
        return this.$data.$id("alpine-disclosure-panel");
      }
    });
  }

  // packages/ui/src/listbox.js
  function listbox_default(Alpine2) {
    Alpine2.directive("listbox", (el, directive) => {
      if (!directive.value)
        handleRoot4(el, Alpine2);
      else if (directive.value === "label")
        handleLabel2(el, Alpine2);
      else if (directive.value === "button")
        handleButton3(el, Alpine2);
      else if (directive.value === "options")
        handleOptions2(el, Alpine2);
      else if (directive.value === "option")
        handleOption2(el, Alpine2);
    }).before("bind");
    Alpine2.magic("listbox", (el) => {
      let data = Alpine2.$data(el);
      return {
        // @deprecated:
        get selected() {
          return data.__value;
        },
        // @deprecated:
        get active() {
          let active = data.__context.getActiveItem();
          return active && active.value;
        },
        get value() {
          return data.__value;
        },
        get isOpen() {
          return data.__isOpen;
        },
        get isDisabled() {
          return data.__isDisabled;
        },
        get activeOption() {
          let active = data.__context.getActiveItem();
          return active && active.value;
        },
        get activeIndex() {
          let active = data.__context.getActiveItem();
          return active && active.key;
        }
      };
    });
    Alpine2.magic("listboxOption", (el) => {
      let data = Alpine2.$data(el);
      let optionEl = Alpine2.findClosest(el, (i) => {
        return i.hasAttribute("x-listbox:option");
      });
      if (!optionEl)
        throw "No x-listbox:option directive found...";
      return {
        get isActive() {
          return data.__context.isActiveKey(Alpine2.$data(optionEl).__optionKey);
        },
        get isSelected() {
          return data.__isSelected(optionEl);
        },
        get isDisabled() {
          return data.__context.isDisabled(Alpine2.$data(optionEl).__optionKey);
        }
      };
    });
  }
  function handleRoot4(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-id"() {
        return ["alpine-listbox-button", "alpine-listbox-options", "alpine-listbox-label"];
      },
      "x-modelable": "__value",
      // Initialize...
      "x-data"() {
        return {
          /**
           * Listbox state...
           */
          __ready: false,
          __value: null,
          __isOpen: false,
          __context: void 0,
          __isMultiple: void 0,
          __isStatic: false,
          __isDisabled: void 0,
          __compareBy: null,
          __inputName: null,
          __orientation: "vertical",
          __hold: false,
          /**
           * Comobox initialization...
           */
          init() {
            this.__isMultiple = Alpine2.extractProp(el, "multiple", false);
            this.__isDisabled = Alpine2.extractProp(el, "disabled", false);
            this.__inputName = Alpine2.extractProp(el, "name", null);
            this.__compareBy = Alpine2.extractProp(el, "by");
            this.__orientation = Alpine2.extractProp(el, "horizontal", false) ? "horizontal" : "vertical";
            this.__context = generateContext(Alpine2, this.__isMultiple, this.__orientation, () => this.$data.__activateSelectedOrFirst());
            let defaultValue = Alpine2.extractProp(el, "default-value", this.__isMultiple ? [] : null);
            this.__value = defaultValue;
            queueMicrotask(() => {
              Alpine2.effect(() => {
                this.__inputName && renderHiddenInputs(Alpine2, this.$el, this.__inputName, this.__value);
              });
              Alpine2.effect(() => {
                this.__resetInput();
              });
            });
          },
          __resetInput() {
            let input = this.$refs.__input;
            if (!input)
              return;
            let value = this.$data.__getCurrentValue();
            input.value = value;
          },
          __getCurrentValue() {
            if (!this.$refs.__input)
              return "";
            if (!this.__value)
              return "";
            if (this.$data.__displayValue && this.__value !== void 0)
              return this.$data.__displayValue(this.__value);
            if (typeof this.__value === "string")
              return this.__value;
            return "";
          },
          __open() {
            if (this.__isOpen)
              return;
            this.__isOpen = true;
            this.__activateSelectedOrFirst();
            let nextTick = (callback) => requestAnimationFrame(() => requestAnimationFrame(callback));
            nextTick(() => this.$refs.__options.focus({ preventScroll: true }));
          },
          __close() {
            this.__isOpen = false;
            this.__context.deactivate();
            this.$nextTick(() => this.$refs.__button.focus({ preventScroll: true }));
          },
          __activateSelectedOrFirst(activateSelected = true) {
            if (!this.__isOpen)
              return;
            if (this.__context.getActiveKey()) {
              this.__context.activateAndScrollToKey(this.__context.getActiveKey());
              return;
            }
            let firstSelectedValue;
            if (this.__isMultiple) {
              firstSelectedValue = this.__value.find((i) => {
                return !!this.__context.getItemByValue(i);
              });
            } else {
              firstSelectedValue = this.__value;
            }
            if (activateSelected && firstSelectedValue) {
              let firstSelected = this.__context.getItemByValue(firstSelectedValue);
              firstSelected && this.__context.activateAndScrollToKey(firstSelected.key);
            } else {
              this.__context.activateAndScrollToKey(this.__context.firstKey());
            }
          },
          __selectActive() {
            let active = this.$data.__context.getActiveItem();
            if (active)
              this.__toggleSelected(active.value);
          },
          __selectOption(el2) {
            let item = this.__context.getItemByEl(el2);
            if (item)
              this.__toggleSelected(item.value);
          },
          __isSelected(el2) {
            let item = this.__context.getItemByEl(el2);
            if (!item)
              return false;
            if (!item.value)
              return false;
            return this.__hasSelected(item.value);
          },
          __toggleSelected(value) {
            if (!this.__isMultiple) {
              this.__value = value;
              return;
            }
            let index = this.__value.findIndex((j) => this.__compare(j, value));
            if (index === -1) {
              this.__value.push(value);
            } else {
              this.__value.splice(index, 1);
            }
          },
          __hasSelected(value) {
            if (!this.__isMultiple)
              return this.__compare(this.__value, value);
            return this.__value.some((i) => this.__compare(i, value));
          },
          __compare(a, b) {
            let by = this.__compareBy;
            if (!by)
              by = (a2, b2) => Alpine2.raw(a2) === Alpine2.raw(b2);
            if (typeof by === "string") {
              let property = by;
              by = (a2, b2) => {
                if (!a2 || typeof a2 !== "object" || (!b2 || typeof b2 !== "object")) {
                  return Alpine2.raw(a2) === Alpine2.raw(b2);
                }
                return a2[property] === b2[property];
              };
            }
            return by(a, b);
          }
        };
      }
    });
  }
  function handleLabel2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-ref": "__label",
      ":id"() {
        return this.$id("alpine-listbox-label");
      },
      "@click"() {
        this.$refs.__button.focus({ preventScroll: true });
      }
    });
  }
  function handleButton3(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-ref": "__button",
      ":id"() {
        return this.$id("alpine-listbox-button");
      },
      // Accessibility attributes...
      "aria-haspopup": "true",
      ":aria-labelledby"() {
        return this.$id("alpine-listbox-label");
      },
      ":aria-expanded"() {
        return this.$data.__isOpen;
      },
      ":aria-controls"() {
        return this.$data.__isOpen && this.$id("alpine-listbox-options");
      },
      // Initialize....
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
      },
      // Register listeners...
      "@click"() {
        this.$data.__open();
      },
      "@keydown"(e) {
        if (["ArrowDown", "ArrowUp", "ArrowLeft", "ArrowRight"].includes(e.key)) {
          e.stopPropagation();
          e.preventDefault();
          this.$data.__open();
        }
      },
      "@keydown.space.stop.prevent"() {
        this.$data.__open();
      },
      "@keydown.enter.stop.prevent"() {
        this.$data.__open();
      }
    });
  }
  function handleOptions2(el, Alpine2) {
    Alpine2.bind(el, {
      // Setup...
      "x-ref": "__options",
      ":id"() {
        return this.$id("alpine-listbox-options");
      },
      // Accessibility attributes...
      "role": "listbox",
      tabindex: "0",
      ":aria-orientation"() {
        return this.$data.__orientation;
      },
      ":aria-labelledby"() {
        return this.$id("alpine-listbox-button");
      },
      ":aria-activedescendant"() {
        if (!this.$data.__context.hasActive())
          return;
        let active = this.$data.__context.getActiveItem();
        return active ? active.el.id : null;
      },
      // Initialize...
      "x-init"() {
        this.$data.__isStatic = Alpine2.extractProp(this.$el, "static", false);
        if (Alpine2.bound(this.$el, "hold")) {
          this.$data.__hold = true;
        }
      },
      "x-show"() {
        return this.$data.__isStatic ? true : this.$data.__isOpen;
      },
      "x-trap"() {
        return this.$data.__isOpen;
      },
      "@click.outside"() {
        this.$data.__close();
      },
      "@keydown.escape.stop.prevent"() {
        this.$data.__close();
      },
      "@focus"() {
        this.$data.__activateSelectedOrFirst();
      },
      "@keydown"(e) {
        queueMicrotask(() => this.$data.__context.activateByKeyEvent(e, true, () => this.$data.__isOpen, () => this.$data.__open(), () => {
        }));
      },
      "@keydown.enter.stop.prevent"() {
        this.$data.__selectActive();
        this.$data.__isMultiple || this.$data.__close();
      },
      "@keydown.space.stop.prevent"() {
        this.$data.__selectActive();
        this.$data.__isMultiple || this.$data.__close();
      }
    });
  }
  function handleOption2(el, Alpine2) {
    Alpine2.bind(el, () => {
      return {
        "x-id"() {
          return ["alpine-listbox-option"];
        },
        ":id"() {
          return this.$id("alpine-listbox-option");
        },
        // Accessibility attributes...
        "role": "option",
        ":tabindex"() {
          return this.$listboxOption.isDisabled ? false : "-1";
        },
        ":aria-selected"() {
          return this.$listboxOption.isSelected;
        },
        // Initialize...
        "x-data"() {
          return {
            "__optionKey": null,
            init() {
              this.__optionKey = (Math.random() + 1).toString(36).substring(7);
              let value = Alpine2.extractProp(el, "value");
              let disabled = Alpine2.extractProp(el, "disabled", false, false);
              this.$data.__context.registerItem(this.__optionKey, el, value, disabled);
            },
            destroy() {
              this.$data.__context.unregisterItem(this.__optionKey);
            }
          };
        },
        // Register listeners...
        "@click"() {
          if (this.$listboxOption.isDisabled)
            return;
          this.$data.__selectOption(el);
          this.$data.__isMultiple || this.$data.__close();
        },
        "@mouseenter"() {
          this.$data.__context.activateEl(el);
        },
        "@mouseleave"() {
          this.$data.__hold || this.$data.__context.deactivate();
        }
      };
    });
  }

  // packages/ui/src/popover.js
  function popover_default(Alpine2) {
    Alpine2.directive("popover", (el, directive) => {
      if (!directive.value)
        handleRoot5(el, Alpine2);
      else if (directive.value === "overlay")
        handleOverlay2(el, Alpine2);
      else if (directive.value === "button")
        handleButton4(el, Alpine2);
      else if (directive.value === "panel")
        handlePanel3(el, Alpine2);
      else if (directive.value === "group")
        handleGroup(el, Alpine2);
    });
    Alpine2.magic("popover", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isOpen() {
          return $data.__isOpenState;
        },
        open() {
          $data.__open();
        },
        close() {
          $data.__close();
        }
      };
    });
  }
  function handleRoot5(el, Alpine2) {
    Alpine2.bind(el, {
      "x-id"() {
        return ["alpine-popover-button", "alpine-popover-panel"];
      },
      "x-modelable": "__isOpenState",
      "x-data"() {
        return {
          init() {
            if (this.$data.__groupEl) {
              this.$data.__groupEl.addEventListener("__close-others", ({ detail }) => {
                if (detail.el.isSameNode(this.$el))
                  return;
                this.__close(false);
              });
            }
          },
          __buttonEl: void 0,
          __panelEl: void 0,
          __isStatic: false,
          get __isOpen() {
            if (this.__isStatic)
              return true;
            return this.__isOpenState;
          },
          __isOpenState: false,
          __open() {
            this.__isOpenState = true;
            this.$dispatch("__close-others", { el: this.$el });
          },
          __toggle() {
            this.__isOpenState ? this.__close() : this.__open();
          },
          __close(el2) {
            if (this.__isStatic)
              return;
            this.__isOpenState = false;
            if (el2 === false)
              return;
            el2 = el2 || this.$data.__buttonEl;
            if (document.activeElement.isSameNode(el2))
              return;
            setTimeout(() => el2.focus());
          },
          __contains(outer, inner) {
            return !!Alpine2.findClosest(inner, (el2) => el2.isSameNode(outer));
          }
        };
      },
      "@keydown.escape.stop.prevent"() {
        this.__close();
      },
      "@focusin.window"() {
        if (this.$data.__groupEl) {
          if (!this.$data.__contains(this.$data.__groupEl, document.activeElement)) {
            this.$data.__close(false);
          }
          return;
        }
        if (!this.$data.__contains(this.$el, document.activeElement)) {
          this.$data.__close(false);
        }
      }
    });
  }
  function handleButton4(el, Alpine2) {
    Alpine2.bind(el, {
      "x-ref": "button",
      ":id"() {
        return this.$id("alpine-popover-button");
      },
      ":aria-expanded"() {
        return this.$data.__isOpen;
      },
      ":aria-controls"() {
        return this.$data.__isOpen && this.$id("alpine-popover-panel");
      },
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
        this.$data.__buttonEl = this.$el;
      },
      "@click"() {
        this.$data.__toggle();
      },
      "@keydown.tab"(e) {
        if (!e.shiftKey && this.$data.__isOpen) {
          let firstFocusableEl = this.$focus.within(this.$data.__panelEl).getFirst();
          if (firstFocusableEl) {
            e.preventDefault();
            e.stopPropagation();
            this.$focus.focus(firstFocusableEl);
          }
        }
      },
      "@keyup.tab"(e) {
        if (this.$data.__isOpen) {
          let lastEl = this.$focus.previouslyFocused();
          if (!lastEl)
            return;
          if (
            // Make sure the last focused wasn't part of this popover.
            !this.$data.__buttonEl.contains(lastEl) && !this.$data.__panelEl.contains(lastEl) && (lastEl && this.$el.compareDocumentPosition(lastEl) & Node.DOCUMENT_POSITION_FOLLOWING)
          ) {
            e.preventDefault();
            e.stopPropagation();
            this.$focus.within(this.$data.__panelEl).last();
          }
        }
      },
      "@keydown.space.stop.prevent"() {
        this.$data.__toggle();
      },
      "@keydown.enter.stop.prevent"() {
        this.$data.__toggle();
      },
      // This is to stop Firefox from firing a "click".
      "@keyup.space.stop.prevent"() {
      }
    });
  }
  function handlePanel3(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__isStatic = Alpine2.bound(this.$el, "static", false);
        this.$data.__panelEl = this.$el;
      },
      "x-effect"() {
        this.$data.__isOpen && Alpine2.bound(el, "focus") && this.$focus.first();
      },
      "x-ref": "panel",
      ":id"() {
        return this.$id("alpine-popover-panel");
      },
      "x-show"() {
        return this.$data.__isOpen;
      },
      "@mousedown.window"($event) {
        if (!this.$data.__isOpen)
          return;
        if (this.$data.__contains(this.$data.__buttonEl, $event.target))
          return;
        if (this.$data.__contains(this.$el, $event.target))
          return;
        if (!this.$focus.focusable($event.target)) {
          this.$data.__close();
        }
      },
      "@keydown.tab"(e) {
        if (e.shiftKey && this.$focus.isFirst(e.target)) {
          e.preventDefault();
          e.stopPropagation();
          Alpine2.bound(el, "focus") ? this.$data.__close() : this.$data.__buttonEl.focus();
        } else if (!e.shiftKey && this.$focus.isLast(e.target)) {
          e.preventDefault();
          e.stopPropagation();
          let els = this.$focus.within(document).all();
          let buttonIdx = els.indexOf(this.$data.__buttonEl);
          let nextEls = els.splice(buttonIdx + 1).filter((el2) => !this.$el.contains(el2));
          nextEls[0].focus();
          Alpine2.bound(el, "focus") && this.$data.__close(false);
        }
      }
    });
  }
  function handleGroup(el, Alpine2) {
    Alpine2.bind(el, {
      "x-ref": "container",
      "x-data"() {
        return {
          __groupEl: this.$el
        };
      }
    });
  }
  function handleOverlay2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-show"() {
        return this.$data.__isOpen;
      }
    });
  }

  // packages/ui/src/menu.js
  function menu_default(Alpine2) {
    Alpine2.directive("menu", (el, directive) => {
      if (!directive.value)
        handleRoot6(el, Alpine2);
      else if (directive.value === "items")
        handleItems(el, Alpine2);
      else if (directive.value === "item")
        handleItem(el, Alpine2);
      else if (directive.value === "button")
        handleButton5(el, Alpine2);
    }).before("bind");
    Alpine2.magic("menuItem", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isActive() {
          return $data.__activeEl == $data.__itemEl;
        },
        get isDisabled() {
          return $data.__itemEl.__isDisabled.value;
        }
      };
    });
  }
  function handleRoot6(el, Alpine2) {
    Alpine2.bind(el, {
      "x-id"() {
        return ["alpine-menu-button", "alpine-menu-items"];
      },
      "x-modelable": "__isOpen",
      "x-data"() {
        return {
          __itemEls: [],
          __activeEl: null,
          __isOpen: false,
          __open(activationStrategy) {
            this.__isOpen = true;
            let nextTick = (callback) => requestAnimationFrame(() => requestAnimationFrame(callback));
            nextTick(() => {
              this.$refs.__items.focus({ preventScroll: true });
              activationStrategy && activationStrategy(Alpine2, this.$refs.__items, (el2) => el2.__activate());
            });
          },
          __close(focusAfter = true) {
            this.__isOpen = false;
            focusAfter && this.$nextTick(() => this.$refs.__button.focus({ preventScroll: true }));
          },
          __contains(outer, inner) {
            return !!Alpine2.findClosest(inner, (el2) => el2.isSameNode(outer));
          }
        };
      },
      "@focusin.window"() {
        if (!this.$data.__contains(this.$el, document.activeElement)) {
          this.$data.__close(false);
        }
      }
    });
  }
  function handleButton5(el, Alpine2) {
    Alpine2.bind(el, {
      "x-ref": "__button",
      "aria-haspopup": "true",
      ":aria-labelledby"() {
        return this.$id("alpine-menu-label");
      },
      ":id"() {
        return this.$id("alpine-menu-button");
      },
      ":aria-expanded"() {
        return this.$data.__isOpen;
      },
      ":aria-controls"() {
        return this.$data.__isOpen && this.$id("alpine-menu-items");
      },
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
      },
      "@click"() {
        this.$data.__open();
      },
      "@keydown.down.stop.prevent"() {
        this.$data.__open();
      },
      "@keydown.up.stop.prevent"() {
        this.$data.__open(dom.last);
      },
      "@keydown.space.stop.prevent"() {
        this.$data.__open();
      },
      "@keydown.enter.stop.prevent"() {
        this.$data.__open();
      }
    });
  }
  function handleItems(el, Alpine2) {
    Alpine2.bind(el, {
      "x-ref": "__items",
      "aria-orientation": "vertical",
      "role": "menu",
      ":id"() {
        return this.$id("alpine-menu-items");
      },
      ":aria-labelledby"() {
        return this.$id("alpine-menu-button");
      },
      ":aria-activedescendant"() {
        return this.$data.__activeEl && this.$data.__activeEl.id;
      },
      "x-show"() {
        return this.$data.__isOpen;
      },
      "tabindex": "0",
      "@click.outside"() {
        this.$data.__close();
      },
      "@keydown"(e) {
        dom.search(Alpine2, this.$refs.__items, e.key, (el2) => el2.__activate());
      },
      "@keydown.down.stop.prevent"() {
        if (this.$data.__activeEl)
          dom.next(Alpine2, this.$data.__activeEl, (el2) => el2.__activate());
        else
          dom.first(Alpine2, this.$refs.__items, (el2) => el2.__activate());
      },
      "@keydown.up.stop.prevent"() {
        if (this.$data.__activeEl)
          dom.previous(Alpine2, this.$data.__activeEl, (el2) => el2.__activate());
        else
          dom.last(Alpine2, this.$refs.__items, (el2) => el2.__activate());
      },
      "@keydown.home.stop.prevent"() {
        dom.first(Alpine2, this.$refs.__items, (el2) => el2.__activate());
      },
      "@keydown.end.stop.prevent"() {
        dom.last(Alpine2, this.$refs.__items, (el2) => el2.__activate());
      },
      "@keydown.page-up.stop.prevent"() {
        dom.first(Alpine2, this.$refs.__items, (el2) => el2.__activate());
      },
      "@keydown.page-down.stop.prevent"() {
        dom.last(Alpine2, this.$refs.__items, (el2) => el2.__activate());
      },
      "@keydown.escape.stop.prevent"() {
        this.$data.__close();
      },
      "@keydown.space.stop.prevent"() {
        this.$data.__activeEl && this.$data.__activeEl.click();
      },
      "@keydown.enter.stop.prevent"() {
        this.$data.__activeEl && this.$data.__activeEl.click();
      },
      // Required for firefox, event.preventDefault() in handleKeyDown for
      // the Space key doesn't cancel the handleKeyUp, which in turn
      // triggers a *click*.
      "@keyup.space.prevent"() {
      }
    });
  }
  function handleItem(el, Alpine2) {
    Alpine2.bind(el, () => {
      return {
        "x-data"() {
          return {
            __itemEl: this.$el,
            init() {
              let els = Alpine2.raw(this.$data.__itemEls);
              let inserted = false;
              for (let i = 0; i < els.length; i++) {
                if (els[i].compareDocumentPosition(this.$el) & Node.DOCUMENT_POSITION_PRECEDING) {
                  els.splice(i, 0, this.$el);
                  inserted = true;
                  break;
                }
              }
              if (!inserted)
                els.push(this.$el);
              this.$el.__activate = () => {
                this.$data.__activeEl = this.$el;
                this.$el.scrollIntoView({ block: "nearest" });
              };
              this.$el.__deactivate = () => {
                this.$data.__activeEl = null;
              };
              this.$el.__isDisabled = Alpine2.reactive({ value: false });
              queueMicrotask(() => {
                this.$el.__isDisabled.value = Alpine2.bound(this.$el, "disabled", false);
              });
            },
            destroy() {
              let els = this.$data.__itemEls;
              els.splice(els.indexOf(this.$el), 1);
            }
          };
        },
        "x-id"() {
          return ["alpine-menu-item"];
        },
        ":id"() {
          return this.$id("alpine-menu-item");
        },
        ":tabindex"() {
          return this.__itemEl.__isDisabled.value ? false : "-1";
        },
        "role": "menuitem",
        "@mousemove"() {
          this.__itemEl.__isDisabled.value || this.$menuItem.isActive || this.__itemEl.__activate();
        },
        "@mouseleave"() {
          this.__itemEl.__isDisabled.value || !this.$menuItem.isActive || this.__itemEl.__deactivate();
        }
      };
    });
  }
  var dom = {
    first(Alpine2, parent, receive = (i) => i, fallback = () => {
    }) {
      let first = Alpine2.$data(parent).__itemEls[0];
      if (!first)
        return fallback();
      if (first.tagName.toLowerCase() === "template") {
        return this.next(Alpine2, first, receive);
      }
      if (first.__isDisabled.value)
        return this.next(Alpine2, first, receive);
      return receive(first);
    },
    last(Alpine2, parent, receive = (i) => i, fallback = () => {
    }) {
      let last = Alpine2.$data(parent).__itemEls.slice(-1)[0];
      if (!last)
        return fallback();
      if (last.__isDisabled.value)
        return this.previous(Alpine2, last, receive);
      return receive(last);
    },
    next(Alpine2, el, receive = (i) => i, fallback = () => {
    }) {
      if (!el)
        return fallback();
      let els = Alpine2.$data(el).__itemEls;
      let next = els[els.indexOf(el) + 1];
      if (!next)
        return fallback();
      if (next.__isDisabled.value || next.tagName.toLowerCase() === "template")
        return this.next(Alpine2, next, receive, fallback);
      return receive(next);
    },
    previous(Alpine2, el, receive = (i) => i, fallback = () => {
    }) {
      if (!el)
        return fallback();
      let els = Alpine2.$data(el).__itemEls;
      let prev = els[els.indexOf(el) - 1];
      if (!prev)
        return fallback();
      if (prev.__isDisabled.value || prev.tagName.toLowerCase() === "template")
        return this.previous(Alpine2, prev, receive, fallback);
      return receive(prev);
    },
    searchQuery: "",
    debouncedClearSearch: void 0,
    clearSearch(Alpine2) {
      if (!this.debouncedClearSearch) {
        this.debouncedClearSearch = Alpine2.debounce(function() {
          this.searchQuery = "";
        }, 350);
      }
      this.debouncedClearSearch();
    },
    search(Alpine2, parent, key, receiver) {
      if (key.length > 1)
        return;
      this.searchQuery += key;
      let els = Alpine2.raw(Alpine2.$data(parent).__itemEls);
      let el = els.find((el2) => {
        return el2.textContent.trim().toLowerCase().startsWith(this.searchQuery);
      });
      el && !el.__isDisabled.value && receiver(el);
      this.clearSearch(Alpine2);
    }
  };

  // packages/ui/src/switch.js
  function switch_default(Alpine2) {
    Alpine2.directive("switch", (el, directive) => {
      if (directive.value === "group")
        handleGroup2(el, Alpine2);
      else if (directive.value === "label")
        handleLabel3(el, Alpine2);
      else if (directive.value === "description")
        handleDescription2(el, Alpine2);
      else
        handleRoot7(el, Alpine2);
    }).before("bind");
    Alpine2.magic("switch", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isChecked() {
          return $data.__value === true;
        }
      };
    });
  }
  function handleGroup2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-id"() {
        return ["alpine-switch-label", "alpine-switch-description"];
      },
      "x-data"() {
        return {
          __hasLabel: false,
          __hasDescription: false,
          __switchEl: void 0
        };
      }
    });
  }
  function handleRoot7(el, Alpine2) {
    Alpine2.bind(el, {
      "x-modelable": "__value",
      "x-data"() {
        return {
          init() {
            queueMicrotask(() => {
              this.__value = Alpine2.bound(this.$el, "default-checked", false);
              this.__inputName = Alpine2.bound(this.$el, "name", false);
              this.__inputValue = Alpine2.bound(this.$el, "value", "on");
              this.__inputId = "alpine-switch-" + Date.now();
            });
          },
          __value: void 0,
          __inputName: void 0,
          __inputValue: void 0,
          __inputId: void 0,
          __toggle() {
            this.__value = !this.__value;
          }
        };
      },
      "x-effect"() {
        let value = this.__value;
        if (!this.__inputName)
          return;
        let nextEl = this.$el.nextElementSibling;
        if (nextEl && String(nextEl.id) === String(this.__inputId)) {
          nextEl.remove();
        }
        if (value) {
          let input = document.createElement("input");
          input.type = "hidden";
          input.value = this.__inputValue;
          input.name = this.__inputName;
          input.id = this.__inputId;
          this.$el.after(input);
        }
      },
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
        this.$data.__switchEl = this.$el;
      },
      "role": "switch",
      "tabindex": "0",
      ":aria-checked"() {
        return !!this.__value;
      },
      ":aria-labelledby"() {
        return this.$data.__hasLabel && this.$id("alpine-switch-label");
      },
      ":aria-describedby"() {
        return this.$data.__hasDescription && this.$id("alpine-switch-description");
      },
      "@click.prevent"() {
        this.__toggle();
      },
      "@keyup"(e) {
        if (e.key !== "Tab")
          e.preventDefault();
        if (e.key === " ")
          this.__toggle();
      },
      // This is needed so that we can "cancel" the click event when we use the `Enter` key on a button.
      "@keypress.prevent"() {
      }
    });
  }
  function handleLabel3(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__hasLabel = true;
      },
      ":id"() {
        return this.$id("alpine-switch-label");
      },
      "@click"() {
        this.$data.__switchEl.click();
        this.$data.__switchEl.focus({ preventScroll: true });
      }
    });
  }
  function handleDescription2(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__hasDescription = true;
      },
      ":id"() {
        return this.$id("alpine-switch-description");
      }
    });
  }

  // packages/ui/src/radio.js
  function radio_default(Alpine2) {
    Alpine2.directive("radio", (el, directive) => {
      if (!directive.value)
        handleRoot8(el, Alpine2);
      else if (directive.value === "option")
        handleOption3(el, Alpine2);
      else if (directive.value === "label")
        handleLabel4(el, Alpine2);
      else if (directive.value === "description")
        handleDescription3(el, Alpine2);
    }).before("bind");
    Alpine2.magic("radioOption", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isActive() {
          return $data.__option === $data.__active;
        },
        get isChecked() {
          return $data.__option === $data.__value;
        },
        get isDisabled() {
          let disabled = $data.__disabled;
          if ($data.__rootDisabled)
            return true;
          return disabled;
        }
      };
    });
  }
  function handleRoot8(el, Alpine2) {
    Alpine2.bind(el, {
      "x-modelable": "__value",
      "x-data"() {
        return {
          init() {
            queueMicrotask(() => {
              this.__rootDisabled = Alpine2.bound(el, "disabled", false);
              this.__value = Alpine2.bound(this.$el, "default-value", false);
              this.__inputName = Alpine2.bound(this.$el, "name", false);
              this.__inputId = "alpine-radio-" + Date.now();
            });
            this.$nextTick(() => {
              let walker = document.createTreeWalker(
                this.$el,
                NodeFilter.SHOW_ELEMENT,
                {
                  acceptNode: (node) => {
                    if (node.getAttribute("role") === "radio")
                      return NodeFilter.FILTER_REJECT;
                    if (node.hasAttribute("role"))
                      return NodeFilter.FILTER_SKIP;
                    return NodeFilter.FILTER_ACCEPT;
                  }
                },
                false
              );
              while (walker.nextNode())
                walker.currentNode.setAttribute("role", "none");
            });
          },
          __value: void 0,
          __active: void 0,
          __rootEl: this.$el,
          __optionValues: [],
          __disabledOptions: /* @__PURE__ */ new Set(),
          __optionElsByValue: /* @__PURE__ */ new Map(),
          __hasLabel: false,
          __hasDescription: false,
          __rootDisabled: false,
          __inputName: void 0,
          __inputId: void 0,
          __change(value) {
            if (this.__rootDisabled)
              return;
            this.__value = value;
          },
          __addOption(option, el2, disabled) {
            let options = Alpine2.raw(this.__optionValues);
            let els = options.map((i) => this.__optionElsByValue.get(i));
            let inserted = false;
            for (let i = 0; i < els.length; i++) {
              if (els[i].compareDocumentPosition(el2) & Node.DOCUMENT_POSITION_PRECEDING) {
                options.splice(i, 0, option);
                this.__optionElsByValue.set(option, el2);
                inserted = true;
                break;
              }
            }
            if (!inserted) {
              options.push(option);
              this.__optionElsByValue.set(option, el2);
            }
            disabled && this.__disabledOptions.add(option);
          },
          __isFirstOption(option) {
            return this.__optionValues.indexOf(option) === 0;
          },
          __setActive(option) {
            this.__active = option;
          },
          __focusOptionNext() {
            let option = this.__active;
            let all = this.__optionValues.filter((i) => !this.__disabledOptions.has(i));
            let next = all[this.__optionValues.indexOf(option) + 1];
            next = next || all[0];
            this.__optionElsByValue.get(next).focus();
            this.__change(next);
          },
          __focusOptionPrev() {
            let option = this.__active;
            let all = this.__optionValues.filter((i) => !this.__disabledOptions.has(i));
            let prev = all[all.indexOf(option) - 1];
            prev = prev || all.slice(-1)[0];
            this.__optionElsByValue.get(prev).focus();
            this.__change(prev);
          }
        };
      },
      "x-effect"() {
        let value = this.__value;
        if (!this.__inputName)
          return;
        let nextEl = this.$el.nextElementSibling;
        if (nextEl && String(nextEl.id) === String(this.__inputId)) {
          nextEl.remove();
        }
        if (value) {
          let input = document.createElement("input");
          input.type = "hidden";
          input.value = value;
          input.name = this.__inputName;
          input.id = this.__inputId;
          this.$el.after(input);
        }
      },
      "role": "radiogroup",
      "x-id"() {
        return ["alpine-radio-label", "alpine-radio-description"];
      },
      ":aria-labelledby"() {
        return this.__hasLabel && this.$id("alpine-radio-label");
      },
      ":aria-describedby"() {
        return this.__hasDescription && this.$id("alpine-radio-description");
      },
      "@keydown.up.prevent.stop"() {
        this.__focusOptionPrev();
      },
      "@keydown.left.prevent.stop"() {
        this.__focusOptionPrev();
      },
      "@keydown.down.prevent.stop"() {
        this.__focusOptionNext();
      },
      "@keydown.right.prevent.stop"() {
        this.__focusOptionNext();
      }
    });
  }
  function handleOption3(el, Alpine2) {
    Alpine2.bind(el, {
      "x-data"() {
        return {
          init() {
            queueMicrotask(() => {
              this.__disabled = Alpine2.bound(el, "disabled", false);
              this.__option = Alpine2.bound(el, "value");
              this.$data.__addOption(this.__option, this.$el, this.__disabled);
            });
          },
          __option: void 0,
          __disabled: false,
          __hasLabel: false,
          __hasDescription: false
        };
      },
      "x-id"() {
        return ["alpine-radio-label", "alpine-radio-description"];
      },
      "role": "radio",
      ":aria-checked"() {
        return this.$radioOption.isChecked;
      },
      ":aria-disabled"() {
        return this.$radioOption.isDisabled;
      },
      ":aria-labelledby"() {
        return this.__hasLabel && this.$id("alpine-radio-label");
      },
      ":aria-describedby"() {
        return this.__hasDescription && this.$id("alpine-radio-description");
      },
      ":tabindex"() {
        if (this.$radioOption.isDisabled)
          return -1;
        if (this.$radioOption.isChecked)
          return 0;
        if (!this.$data.__value && this.$data.__isFirstOption(this.$data.__option))
          return 0;
        return -1;
      },
      "@click"() {
        if (this.$radioOption.isDisabled)
          return;
        this.$data.__change(this.$data.__option);
        this.$el.focus();
      },
      "@focus"() {
        if (this.$radioOption.isDisabled)
          return;
        this.$data.__setActive(this.$data.__option);
      },
      "@blur"() {
        if (this.$data.__active === this.$data.__option)
          this.$data.__setActive(void 0);
      },
      "@keydown.space.stop.prevent"() {
        this.$data.__change(this.$data.__option);
      }
    });
  }
  function handleLabel4(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__hasLabel = true;
      },
      ":id"() {
        return this.$id("alpine-radio-label");
      }
    });
  }
  function handleDescription3(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__hasDescription = true;
      },
      ":id"() {
        return this.$id("alpine-radio-description");
      }
    });
  }

  // packages/ui/src/tabs.js
  function tabs_default(Alpine2) {
    Alpine2.directive("tabs", (el, directive) => {
      if (!directive.value)
        handleRoot9(el, Alpine2);
      else if (directive.value === "list")
        handleList(el, Alpine2);
      else if (directive.value === "tab")
        handleTab(el, Alpine2);
      else if (directive.value === "panels")
        handlePanels(el, Alpine2);
      else if (directive.value === "panel")
        handlePanel4(el, Alpine2);
    }).before("bind");
    Alpine2.magic("tab", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isSelected() {
          return $data.__selectedIndex === $data.__tabs.indexOf($data.__tabEl);
        },
        get isDisabled() {
          return $data.__isDisabled;
        }
      };
    });
    Alpine2.magic("panel", (el) => {
      let $data = Alpine2.$data(el);
      return {
        get isSelected() {
          return $data.__selectedIndex === $data.__panels.indexOf($data.__panelEl);
        }
      };
    });
  }
  function handleRoot9(el, Alpine2) {
    Alpine2.bind(el, {
      "x-modelable": "__selectedIndex",
      "x-data"() {
        return {
          init() {
            queueMicrotask(() => {
              let defaultIndex = this.__selectedIndex || Number(Alpine2.bound(this.$el, "default-index", 0));
              let tabs = this.__activeTabs();
              let clamp = (number, min, max) => Math.min(Math.max(number, min), max);
              this.__selectedIndex = clamp(defaultIndex, 0, tabs.length - 1);
              Alpine2.effect(() => {
                this.__manualActivation = Alpine2.bound(this.$el, "manual", false);
              });
            });
          },
          __tabs: [],
          __panels: [],
          __selectedIndex: null,
          __tabGroupEl: void 0,
          __manualActivation: false,
          __addTab(el2) {
            this.__tabs.push(el2);
          },
          __addPanel(el2) {
            this.__panels.push(el2);
          },
          __selectTab(el2) {
            this.__selectedIndex = this.__tabs.indexOf(el2);
          },
          __activeTabs() {
            return this.__tabs.filter((i) => !i.__disabled);
          }
        };
      }
    });
  }
  function handleList(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        this.$data.__tabGroupEl = this.$el;
      }
    });
  }
  function handleTab(el, Alpine2) {
    Alpine2.bind(el, {
      "x-init"() {
        if (this.$el.tagName.toLowerCase() === "button" && !this.$el.hasAttribute("type"))
          this.$el.type = "button";
      },
      "x-data"() {
        return {
          init() {
            this.__tabEl = this.$el;
            this.$data.__addTab(this.$el);
            this.__tabEl.__disabled = Alpine2.bound(this.$el, "disabled", false);
            this.__isDisabled = this.__tabEl.__disabled;
          },
          __tabEl: void 0,
          __isDisabled: false
        };
      },
      "@click"() {
        if (this.$el.__disabled)
          return;
        this.$data.__selectTab(this.$el);
        this.$el.focus();
      },
      "@keydown.enter.prevent.stop"() {
        this.__selectTab(this.$el);
      },
      "@keydown.space.prevent.stop"() {
        this.__selectTab(this.$el);
      },
      "@keydown.home.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).first();
      },
      "@keydown.page-up.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).first();
      },
      "@keydown.end.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).last();
      },
      "@keydown.page-down.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).last();
      },
      "@keydown.down.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).withWrapAround().next();
      },
      "@keydown.right.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).withWrapAround().next();
      },
      "@keydown.up.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).withWrapAround().prev();
      },
      "@keydown.left.prevent.stop"() {
        this.$focus.within(this.$data.__activeTabs()).withWrapAround().prev();
      },
      ":tabindex"() {
        return this.$tab.isSelected ? 0 : -1;
      },
      "@focus"() {
        if (this.$data.__manualActivation) {
          this.$el.focus();
        } else {
          if (this.$el.__disabled)
            return;
          this.$data.__selectTab(this.$el);
          this.$el.focus();
        }
      }
    });
  }
  function handlePanels(el, Alpine2) {
    Alpine2.bind(el, {
      //
    });
  }
  function handlePanel4(el, Alpine2) {
    Alpine2.bind(el, {
      ":tabindex"() {
        return this.$panel.isSelected ? 0 : -1;
      },
      "x-data"() {
        return {
          init() {
            this.__panelEl = this.$el;
            this.$data.__addPanel(this.$el);
          },
          __panelEl: void 0
        };
      },
      "x-show"() {
        return this.$panel.isSelected;
      }
    });
  }

  // packages/ui/src/index.js
  function src_default$5(Alpine2) {
    combobox_default(Alpine2);
    dialog_default(Alpine2);
    disclosure_default(Alpine2);
    listbox_default(Alpine2);
    menu_default(Alpine2);
    switch_default(Alpine2);
    popover_default(Alpine2);
    radio_default(Alpine2);
    tabs_default(Alpine2);
  }

  // packages/ui/builds/module.js
  var module_default$5 = src_default$5;

  // packages/collapse/src/index.js
  function src_default$4(Alpine) {
    Alpine.directive("collapse", collapse);
    collapse.inline = (el, { modifiers }) => {
      if (!modifiers.includes("min"))
        return;
      el._x_doShow = () => {
      };
      el._x_doHide = () => {
      };
    };
    function collapse(el, { modifiers }) {
      let duration = modifierValue$1(modifiers, "duration", 250) / 1e3;
      let floor = modifierValue$1(modifiers, "min", 0);
      let fullyHide = !modifiers.includes("min");
      if (!el._x_isShown)
        el.style.height = `${floor}px`;
      if (!el._x_isShown && fullyHide)
        el.hidden = true;
      if (!el._x_isShown)
        el.style.overflow = "hidden";
      let setFunction = (el2, styles) => {
        let revertFunction = Alpine.setStyles(el2, styles);
        return styles.height ? () => {
        } : revertFunction;
      };
      let transitionStyles = {
        transitionProperty: "height",
        transitionDuration: `${duration}s`,
        transitionTimingFunction: "cubic-bezier(0.4, 0.0, 0.2, 1)"
      };
      el._x_transition = {
        in(before = () => {
        }, after = () => {
        }) {
          if (fullyHide)
            el.hidden = false;
          if (fullyHide)
            el.style.display = null;
          let current = el.getBoundingClientRect().height;
          el.style.height = "auto";
          let full = el.getBoundingClientRect().height;
          if (current === full) {
            current = floor;
          }
          Alpine.transition(el, Alpine.setStyles, {
            during: transitionStyles,
            start: { height: current + "px" },
            end: { height: full + "px" }
          }, () => el._x_isShown = true, () => {
            if (el.getBoundingClientRect().height == full) {
              el.style.overflow = null;
            }
          });
        },
        out(before = () => {
        }, after = () => {
        }) {
          let full = el.getBoundingClientRect().height;
          Alpine.transition(el, setFunction, {
            during: transitionStyles,
            start: { height: full + "px" },
            end: { height: floor + "px" }
          }, () => el.style.overflow = "hidden", () => {
            el._x_isShown = false;
            if (el.style.height == `${floor}px` && fullyHide) {
              el.style.display = "none";
              el.hidden = true;
            }
          });
        }
      };
    }
  }
  function modifierValue$1(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "duration") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "min") {
      let match = rawValue.match(/([0-9]+)px/);
      if (match)
        return match[1];
    }
    return rawValue;
  }

  // packages/collapse/builds/module.js
  var module_default$4 = src_default$4;

  // node_modules/tabbable/dist/index.esm.js
  var candidateSelectors = ["input", "select", "textarea", "a[href]", "button", "[tabindex]:not(slot)", "audio[controls]", "video[controls]", '[contenteditable]:not([contenteditable="false"])', "details>summary:first-of-type", "details"];
  var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
  var NoElement = typeof Element === "undefined";
  var matches = NoElement ? function() {
  } : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
  var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
    return element.getRootNode();
  } : function(element) {
    return element.ownerDocument;
  };
  var getCandidates = function getCandidates2(el, includeContainer, filter) {
    var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
    if (includeContainer && matches.call(el, candidateSelector)) {
      candidates.unshift(el);
    }
    candidates = candidates.filter(filter);
    return candidates;
  };
  var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
    var candidates = [];
    var elementsToCheck = Array.from(elements);
    while (elementsToCheck.length) {
      var element = elementsToCheck.shift();
      if (element.tagName === "SLOT") {
        var assigned = element.assignedElements();
        var content = assigned.length ? assigned : element.children;
        var nestedCandidates = getCandidatesIteratively2(content, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, nestedCandidates);
        } else {
          candidates.push({
            scope: element,
            candidates: nestedCandidates
          });
        }
      } else {
        var validCandidate = matches.call(element, candidateSelector);
        if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
          candidates.push(element);
        }
        var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
        typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
        var validShadowRoot = !options.shadowRootFilter || options.shadowRootFilter(element);
        if (shadowRoot && validShadowRoot) {
          var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
          if (options.flatten) {
            candidates.push.apply(candidates, _nestedCandidates);
          } else {
            candidates.push({
              scope: element,
              candidates: _nestedCandidates
            });
          }
        } else {
          elementsToCheck.unshift.apply(elementsToCheck, element.children);
        }
      }
    }
    return candidates;
  };
  var getTabindex = function getTabindex2(node, isScope) {
    if (node.tabIndex < 0) {
      if ((isScope || /^(AUDIO|VIDEO|DETAILS)$/.test(node.tagName) || node.isContentEditable) && isNaN(parseInt(node.getAttribute("tabindex"), 10))) {
        return 0;
      }
    }
    return node.tabIndex;
  };
  var sortOrderedTabbables = function sortOrderedTabbables2(a, b) {
    return a.tabIndex === b.tabIndex ? a.documentOrder - b.documentOrder : a.tabIndex - b.tabIndex;
  };
  var isInput = function isInput2(node) {
    return node.tagName === "INPUT";
  };
  var isHiddenInput = function isHiddenInput2(node) {
    return isInput(node) && node.type === "hidden";
  };
  var isDetailsWithSummary = function isDetailsWithSummary2(node) {
    var r = node.tagName === "DETAILS" && Array.prototype.slice.apply(node.children).some(function(child) {
      return child.tagName === "SUMMARY";
    });
    return r;
  };
  var getCheckedRadio = function getCheckedRadio2(nodes, form) {
    for (var i = 0; i < nodes.length; i++) {
      if (nodes[i].checked && nodes[i].form === form) {
        return nodes[i];
      }
    }
  };
  var isTabbableRadio = function isTabbableRadio2(node) {
    if (!node.name) {
      return true;
    }
    var radioScope = node.form || getRootNode(node);
    var queryRadios = function queryRadios2(name) {
      return radioScope.querySelectorAll('input[type="radio"][name="' + name + '"]');
    };
    var radioSet;
    if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
      radioSet = queryRadios(window.CSS.escape(node.name));
    } else {
      try {
        radioSet = queryRadios(node.name);
      } catch (err) {
        console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
        return false;
      }
    }
    var checked = getCheckedRadio(radioSet, node.form);
    return !checked || checked === node;
  };
  var isRadio = function isRadio2(node) {
    return isInput(node) && node.type === "radio";
  };
  var isNonTabbableRadio = function isNonTabbableRadio2(node) {
    return isRadio(node) && !isTabbableRadio(node);
  };
  var isZeroArea = function isZeroArea2(node) {
    var _node$getBoundingClie = node.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
    return width === 0 && height === 0;
  };
  var isHidden = function isHidden2(node, _ref) {
    var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
    if (getComputedStyle(node).visibility === "hidden") {
      return true;
    }
    var isDirectSummary = matches.call(node, "details>summary:first-of-type");
    var nodeUnderDetails = isDirectSummary ? node.parentElement : node;
    if (matches.call(nodeUnderDetails, "details:not([open]) *")) {
      return true;
    }
    var nodeRootHost = getRootNode(node).host;
    var nodeIsAttached = (nodeRootHost === null || nodeRootHost === void 0 ? void 0 : nodeRootHost.ownerDocument.contains(nodeRootHost)) || node.ownerDocument.contains(node);
    if (!displayCheck || displayCheck === "full") {
      if (typeof getShadowRoot === "function") {
        var originalNode = node;
        while (node) {
          var parentElement = node.parentElement;
          var rootNode = getRootNode(node);
          if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
            return isZeroArea(node);
          } else if (node.assignedSlot) {
            node = node.assignedSlot;
          } else if (!parentElement && rootNode !== node.ownerDocument) {
            node = rootNode.host;
          } else {
            node = parentElement;
          }
        }
        node = originalNode;
      }
      if (nodeIsAttached) {
        return !node.getClientRects().length;
      }
    } else if (displayCheck === "non-zero-area") {
      return isZeroArea(node);
    }
    return false;
  };
  var isDisabledFromFieldset = function isDisabledFromFieldset2(node) {
    if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node.tagName)) {
      var parentNode = node.parentElement;
      while (parentNode) {
        if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
          for (var i = 0; i < parentNode.children.length; i++) {
            var child = parentNode.children.item(i);
            if (child.tagName === "LEGEND") {
              return matches.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node);
            }
          }
          return true;
        }
        parentNode = parentNode.parentElement;
      }
    }
    return false;
  };
  var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node) {
    if (node.disabled || isHiddenInput(node) || isHidden(node, options) || // For a details element with a summary, the summary element gets the focus
    isDetailsWithSummary(node) || isDisabledFromFieldset(node)) {
      return false;
    }
    return true;
  };
  var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node) {
    if (isNonTabbableRadio(node) || getTabindex(node) < 0 || !isNodeMatchingSelectorFocusable(options, node)) {
      return false;
    }
    return true;
  };
  var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
    var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
    if (isNaN(tabIndex) || tabIndex >= 0) {
      return true;
    }
    return false;
  };
  var sortByOrder = function sortByOrder2(candidates) {
    var regularTabbables = [];
    var orderedTabbables = [];
    candidates.forEach(function(item, i) {
      var isScope = !!item.scope;
      var element = isScope ? item.scope : item;
      var candidateTabindex = getTabindex(element, isScope);
      var elements = isScope ? sortByOrder2(item.candidates) : element;
      if (candidateTabindex === 0) {
        isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
      } else {
        orderedTabbables.push({
          documentOrder: i,
          tabIndex: candidateTabindex,
          item,
          isScope,
          content: elements
        });
      }
    });
    return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
      sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
      return acc;
    }, []).concat(regularTabbables);
  };
  var tabbable = function tabbable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorTabbable.bind(null, options),
        flatten: false,
        getShadowRoot: options.getShadowRoot,
        shadowRootFilter: isValidShadowRootTabbable
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
    }
    return sortByOrder(candidates);
  };
  var focusable = function focusable2(el, options) {
    options = options || {};
    var candidates;
    if (options.getShadowRoot) {
      candidates = getCandidatesIteratively([el], options.includeContainer, {
        filter: isNodeMatchingSelectorFocusable.bind(null, options),
        flatten: true,
        getShadowRoot: options.getShadowRoot
      });
    } else {
      candidates = getCandidates(el, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
    }
    return candidates;
  };
  var isTabbable = function isTabbable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, candidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorTabbable(options, node);
  };
  var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
  var isFocusable = function isFocusable2(node, options) {
    options = options || {};
    if (!node) {
      throw new Error("No node provided");
    }
    if (matches.call(node, focusableCandidateSelector) === false) {
      return false;
    }
    return isNodeMatchingSelectorFocusable(options, node);
  };

  // node_modules/focus-trap/dist/focus-trap.esm.js
  function ownKeys$1(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      enumerableOnly && (symbols = symbols.filter(function(sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      })), keys.push.apply(keys, symbols);
    }
    return keys;
  }
  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = null != arguments[i] ? arguments[i] : {};
      i % 2 ? ownKeys$1(Object(source), true).forEach(function(key) {
        _defineProperty(target, key, source[key]);
      }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function(key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
    return target;
  }
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
    return obj;
  }
  var activeFocusTraps = function() {
    var trapQueue = [];
    return {
      activateTrap: function activateTrap(trap) {
        if (trapQueue.length > 0) {
          var activeTrap = trapQueue[trapQueue.length - 1];
          if (activeTrap !== trap) {
            activeTrap.pause();
          }
        }
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex === -1) {
          trapQueue.push(trap);
        } else {
          trapQueue.splice(trapIndex, 1);
          trapQueue.push(trap);
        }
      },
      deactivateTrap: function deactivateTrap(trap) {
        var trapIndex = trapQueue.indexOf(trap);
        if (trapIndex !== -1) {
          trapQueue.splice(trapIndex, 1);
        }
        if (trapQueue.length > 0) {
          trapQueue[trapQueue.length - 1].unpause();
        }
      }
    };
  }();
  var isSelectableInput = function isSelectableInput2(node) {
    return node.tagName && node.tagName.toLowerCase() === "input" && typeof node.select === "function";
  };
  var isEscapeEvent = function isEscapeEvent2(e) {
    return e.key === "Escape" || e.key === "Esc" || e.keyCode === 27;
  };
  var isTabEvent = function isTabEvent2(e) {
    return e.key === "Tab" || e.keyCode === 9;
  };
  var delay = function delay2(fn) {
    return setTimeout(fn, 0);
  };
  var findIndex = function findIndex2(arr, fn) {
    var idx = -1;
    arr.every(function(value, i) {
      if (fn(value)) {
        idx = i;
        return false;
      }
      return true;
    });
    return idx;
  };
  var valueOrHandler = function valueOrHandler2(value) {
    for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      params[_key - 1] = arguments[_key];
    }
    return typeof value === "function" ? value.apply(void 0, params) : value;
  };
  var getActualTarget = function getActualTarget2(event) {
    return event.target.shadowRoot && typeof event.composedPath === "function" ? event.composedPath()[0] : event.target;
  };
  var createFocusTrap = function createFocusTrap2(elements, userOptions) {
    var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
    var config = _objectSpread2({
      returnFocusOnDeactivate: true,
      escapeDeactivates: true,
      delayInitialFocus: true
    }, userOptions);
    var state = {
      // containers given to createFocusTrap()
      // @type {Array<HTMLElement>}
      containers: [],
      // list of objects identifying tabbable nodes in `containers` in the trap
      // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
      //  is active, but the trap should never get to a state where there isn't at least one group
      //  with at least one tabbable node in it (that would lead to an error condition that would
      //  result in an error being thrown)
      // @type {Array<{
      //   container: HTMLElement,
      //   tabbableNodes: Array<HTMLElement>, // empty if none
      //   focusableNodes: Array<HTMLElement>, // empty if none
      //   firstTabbableNode: HTMLElement|null,
      //   lastTabbableNode: HTMLElement|null,
      //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
      // }>}
      containerGroups: [],
      // same order/length as `containers` list
      // references to objects in `containerGroups`, but only those that actually have
      //  tabbable nodes in them
      // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
      //  the same length
      tabbableGroups: [],
      nodeFocusedBeforeActivation: null,
      mostRecentlyFocusedNode: null,
      active: false,
      paused: false,
      // timer ID for when delayInitialFocus is true and initial focus in this trap
      //  has been delayed during activation
      delayInitialFocusTimer: void 0
    };
    var trap;
    var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
      return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
    };
    var findContainerIndex = function findContainerIndex2(element) {
      return state.containerGroups.findIndex(function(_ref) {
        var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
        return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
        //  web components if the `tabbableOptions.getShadowRoot` option was used for
        //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
        //  look inside web components even if open)
        tabbableNodes.find(function(node) {
          return node === element;
        });
      });
    };
    var getNodeForOption = function getNodeForOption2(optionName) {
      var optionValue = config[optionName];
      if (typeof optionValue === "function") {
        for (var _len2 = arguments.length, params = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          params[_key2 - 1] = arguments[_key2];
        }
        optionValue = optionValue.apply(void 0, params);
      }
      if (optionValue === true) {
        optionValue = void 0;
      }
      if (!optionValue) {
        if (optionValue === void 0 || optionValue === false) {
          return optionValue;
        }
        throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
      }
      var node = optionValue;
      if (typeof optionValue === "string") {
        node = doc.querySelector(optionValue);
        if (!node) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
      return node;
    };
    var getInitialFocusNode = function getInitialFocusNode2() {
      var node = getNodeForOption("initialFocus");
      if (node === false) {
        return false;
      }
      if (node === void 0) {
        if (findContainerIndex(doc.activeElement) >= 0) {
          node = doc.activeElement;
        } else {
          var firstTabbableGroup = state.tabbableGroups[0];
          var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
          node = firstTabbableNode || getNodeForOption("fallbackFocus");
        }
      }
      if (!node) {
        throw new Error("Your focus-trap needs to have at least one focusable element");
      }
      return node;
    };
    var updateTabbableNodes = function updateTabbableNodes2() {
      state.containerGroups = state.containers.map(function(container) {
        var tabbableNodes = tabbable(container, config.tabbableOptions);
        var focusableNodes = focusable(container, config.tabbableOptions);
        return {
          container,
          tabbableNodes,
          focusableNodes,
          firstTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[0] : null,
          lastTabbableNode: tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : null,
          /**
           * Finds the __tabbable__ node that follows the given node in the specified direction,
           *  in this container, if any.
           * @param {HTMLElement} node
           * @param {boolean} [forward] True if going in forward tab order; false if going
           *  in reverse.
           * @returns {HTMLElement|undefined} The next tabbable node, if any.
           */
          nextTabbableNode: function nextTabbableNode(node) {
            var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
            var nodeIdx = focusableNodes.findIndex(function(n) {
              return n === node;
            });
            if (nodeIdx < 0) {
              return void 0;
            }
            if (forward) {
              return focusableNodes.slice(nodeIdx + 1).find(function(n) {
                return isTabbable(n, config.tabbableOptions);
              });
            }
            return focusableNodes.slice(0, nodeIdx).reverse().find(function(n) {
              return isTabbable(n, config.tabbableOptions);
            });
          }
        };
      });
      state.tabbableGroups = state.containerGroups.filter(function(group) {
        return group.tabbableNodes.length > 0;
      });
      if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
        throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
      }
    };
    var tryFocus = function tryFocus2(node) {
      if (node === false) {
        return;
      }
      if (node === doc.activeElement) {
        return;
      }
      if (!node || !node.focus) {
        tryFocus2(getInitialFocusNode());
        return;
      }
      node.focus({
        preventScroll: !!config.preventScroll
      });
      state.mostRecentlyFocusedNode = node;
      if (isSelectableInput(node)) {
        node.select();
      }
    };
    var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
      var node = getNodeForOption("setReturnFocus", previousActiveElement);
      return node ? node : node === false ? false : previousActiveElement;
    };
    var checkPointerDown = function checkPointerDown2(e) {
      var target = getActualTarget(e);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e)) {
        trap.deactivate({
          // if, on deactivation, we should return focus to the node originally-focused
          //  when the trap was activated (or the configured `setReturnFocus` node),
          //  then assume it's also OK to return focus to the outside node that was
          //  just clicked, causing deactivation, as long as that node is focusable;
          //  if it isn't focusable, then return focus to the original node focused
          //  on activation (or the configured `setReturnFocus` node)
          // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
          //  which will result in the outside click setting focus to the node
          //  that was clicked, whether it's focusable or not; by setting
          //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
          //  on activation (or the configured `setReturnFocus` node)
          returnFocus: config.returnFocusOnDeactivate && !isFocusable(target, config.tabbableOptions)
        });
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e)) {
        return;
      }
      e.preventDefault();
    };
    var checkFocusIn = function checkFocusIn2(e) {
      var target = getActualTarget(e);
      var targetContained = findContainerIndex(target) >= 0;
      if (targetContained || target instanceof Document) {
        if (targetContained) {
          state.mostRecentlyFocusedNode = target;
        }
      } else {
        e.stopImmediatePropagation();
        tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    };
    var checkTab = function checkTab2(e) {
      var target = getActualTarget(e);
      updateTabbableNodes();
      var destinationNode = null;
      if (state.tabbableGroups.length > 0) {
        var containerIndex = findContainerIndex(target);
        var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
        if (containerIndex < 0) {
          if (e.shiftKey) {
            destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
          } else {
            destinationNode = state.tabbableGroups[0].firstTabbableNode;
          }
        } else if (e.shiftKey) {
          var startOfGroupIndex = findIndex(state.tabbableGroups, function(_ref2) {
            var firstTabbableNode = _ref2.firstTabbableNode;
            return target === firstTabbableNode;
          });
          if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
            startOfGroupIndex = containerIndex;
          }
          if (startOfGroupIndex >= 0) {
            var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
            var destinationGroup = state.tabbableGroups[destinationGroupIndex];
            destinationNode = destinationGroup.lastTabbableNode;
          }
        } else {
          var lastOfGroupIndex = findIndex(state.tabbableGroups, function(_ref3) {
            var lastTabbableNode = _ref3.lastTabbableNode;
            return target === lastTabbableNode;
          });
          if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
            lastOfGroupIndex = containerIndex;
          }
          if (lastOfGroupIndex >= 0) {
            var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
            var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
            destinationNode = _destinationGroup.firstTabbableNode;
          }
        }
      } else {
        destinationNode = getNodeForOption("fallbackFocus");
      }
      if (destinationNode) {
        e.preventDefault();
        tryFocus(destinationNode);
      }
    };
    var checkKey = function checkKey2(e) {
      if (isEscapeEvent(e) && valueOrHandler(config.escapeDeactivates, e) !== false) {
        e.preventDefault();
        trap.deactivate();
        return;
      }
      if (isTabEvent(e)) {
        checkTab(e);
        return;
      }
    };
    var checkClick = function checkClick2(e) {
      var target = getActualTarget(e);
      if (findContainerIndex(target) >= 0) {
        return;
      }
      if (valueOrHandler(config.clickOutsideDeactivates, e)) {
        return;
      }
      if (valueOrHandler(config.allowOutsideClick, e)) {
        return;
      }
      e.preventDefault();
      e.stopImmediatePropagation();
    };
    var addListeners = function addListeners2() {
      if (!state.active) {
        return;
      }
      activeFocusTraps.activateTrap(trap);
      state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
        tryFocus(getInitialFocusNode());
      }) : tryFocus(getInitialFocusNode());
      doc.addEventListener("focusin", checkFocusIn, true);
      doc.addEventListener("mousedown", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("touchstart", checkPointerDown, {
        capture: true,
        passive: false
      });
      doc.addEventListener("click", checkClick, {
        capture: true,
        passive: false
      });
      doc.addEventListener("keydown", checkKey, {
        capture: true,
        passive: false
      });
      return trap;
    };
    var removeListeners = function removeListeners2() {
      if (!state.active) {
        return;
      }
      doc.removeEventListener("focusin", checkFocusIn, true);
      doc.removeEventListener("mousedown", checkPointerDown, true);
      doc.removeEventListener("touchstart", checkPointerDown, true);
      doc.removeEventListener("click", checkClick, true);
      doc.removeEventListener("keydown", checkKey, true);
      return trap;
    };
    trap = {
      get active() {
        return state.active;
      },
      get paused() {
        return state.paused;
      },
      activate: function activate(activateOptions) {
        if (state.active) {
          return this;
        }
        var onActivate = getOption(activateOptions, "onActivate");
        var onPostActivate = getOption(activateOptions, "onPostActivate");
        var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
        if (!checkCanFocusTrap) {
          updateTabbableNodes();
        }
        state.active = true;
        state.paused = false;
        state.nodeFocusedBeforeActivation = doc.activeElement;
        if (onActivate) {
          onActivate();
        }
        var finishActivation = function finishActivation2() {
          if (checkCanFocusTrap) {
            updateTabbableNodes();
          }
          addListeners();
          if (onPostActivate) {
            onPostActivate();
          }
        };
        if (checkCanFocusTrap) {
          checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
          return this;
        }
        finishActivation();
        return this;
      },
      deactivate: function deactivate(deactivateOptions) {
        if (!state.active) {
          return this;
        }
        var options = _objectSpread2({
          onDeactivate: config.onDeactivate,
          onPostDeactivate: config.onPostDeactivate,
          checkCanReturnFocus: config.checkCanReturnFocus
        }, deactivateOptions);
        clearTimeout(state.delayInitialFocusTimer);
        state.delayInitialFocusTimer = void 0;
        removeListeners();
        state.active = false;
        state.paused = false;
        activeFocusTraps.deactivateTrap(trap);
        var onDeactivate = getOption(options, "onDeactivate");
        var onPostDeactivate = getOption(options, "onPostDeactivate");
        var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
        var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
        if (onDeactivate) {
          onDeactivate();
        }
        var finishDeactivation = function finishDeactivation2() {
          delay(function() {
            if (returnFocus) {
              tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
            }
            if (onPostDeactivate) {
              onPostDeactivate();
            }
          });
        };
        if (returnFocus && checkCanReturnFocus) {
          checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
          return this;
        }
        finishDeactivation();
        return this;
      },
      pause: function pause() {
        if (state.paused || !state.active) {
          return this;
        }
        state.paused = true;
        removeListeners();
        return this;
      },
      unpause: function unpause() {
        if (!state.paused || !state.active) {
          return this;
        }
        state.paused = false;
        updateTabbableNodes();
        addListeners();
        return this;
      },
      updateContainerElements: function updateContainerElements(containerElements) {
        var elementsAsArray = [].concat(containerElements).filter(Boolean);
        state.containers = elementsAsArray.map(function(element) {
          return typeof element === "string" ? doc.querySelector(element) : element;
        });
        if (state.active) {
          updateTabbableNodes();
        }
        return this;
      }
    };
    trap.updateContainerElements(elements);
    return trap;
  };

  // packages/focus/src/index.js
  function src_default$3(Alpine) {
    let lastFocused;
    let currentFocused;
    window.addEventListener("focusin", () => {
      lastFocused = currentFocused;
      currentFocused = document.activeElement;
    });
    Alpine.magic("focus", (el) => {
      let within = el;
      return {
        __noscroll: false,
        __wrapAround: false,
        within(el2) {
          within = el2;
          return this;
        },
        withoutScrolling() {
          this.__noscroll = true;
          return this;
        },
        noscroll() {
          this.__noscroll = true;
          return this;
        },
        withWrapAround() {
          this.__wrapAround = true;
          return this;
        },
        wrap() {
          return this.withWrapAround();
        },
        focusable(el2) {
          return isFocusable(el2);
        },
        previouslyFocused() {
          return lastFocused;
        },
        lastFocused() {
          return lastFocused;
        },
        focused() {
          return currentFocused;
        },
        focusables() {
          if (Array.isArray(within))
            return within;
          return focusable(within, { displayCheck: "none" });
        },
        all() {
          return this.focusables();
        },
        isFirst(el2) {
          let els = this.all();
          return els[0] && els[0].isSameNode(el2);
        },
        isLast(el2) {
          let els = this.all();
          return els.length && els.slice(-1)[0].isSameNode(el2);
        },
        getFirst() {
          return this.all()[0];
        },
        getLast() {
          return this.all().slice(-1)[0];
        },
        getNext() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === list.length - 1) {
            return list[0];
          }
          return list[list.indexOf(current) + 1];
        },
        getPrevious() {
          let list = this.all();
          let current = document.activeElement;
          if (list.indexOf(current) === -1)
            return;
          if (this.__wrapAround && list.indexOf(current) === 0) {
            return list.slice(-1)[0];
          }
          return list[list.indexOf(current) - 1];
        },
        first() {
          this.focus(this.getFirst());
        },
        last() {
          this.focus(this.getLast());
        },
        next() {
          this.focus(this.getNext());
        },
        previous() {
          this.focus(this.getPrevious());
        },
        prev() {
          return this.previous();
        },
        focus(el2) {
          if (!el2)
            return;
          setTimeout(() => {
            if (!el2.hasAttribute("tabindex"))
              el2.setAttribute("tabindex", "0");
            el2.focus({ preventScroll: this._noscroll });
          });
        }
      };
    });
    Alpine.directive("trap", Alpine.skipDuringClone(
      (el, { expression, modifiers }, { effect, evaluateLater, cleanup }) => {
        let evaluator = evaluateLater(expression);
        let oldValue = false;
        let options = {
          escapeDeactivates: false,
          allowOutsideClick: true,
          fallbackFocus: () => el
        };
        if (modifiers.includes("noautofocus")) {
          options.initialFocus = false;
        } else {
          let autofocusEl = el.querySelector("[autofocus]");
          if (autofocusEl)
            options.initialFocus = autofocusEl;
        }
        let trap = createFocusTrap(el, options);
        let undoInert = () => {
        };
        let undoDisableScrolling = () => {
        };
        const releaseFocus = () => {
          undoInert();
          undoInert = () => {
          };
          undoDisableScrolling();
          undoDisableScrolling = () => {
          };
          trap.deactivate({
            returnFocus: !modifiers.includes("noreturn")
          });
        };
        effect(() => evaluator((value) => {
          if (oldValue === value)
            return;
          if (value && !oldValue) {
            if (modifiers.includes("noscroll"))
              undoDisableScrolling = disableScrolling();
            if (modifiers.includes("inert"))
              undoInert = setInert(el);
            setTimeout(() => {
              trap.activate();
            }, 15);
          }
          if (!value && oldValue) {
            releaseFocus();
          }
          oldValue = !!value;
        }));
        cleanup(releaseFocus);
      },
      // When cloning, we only want to add aria-hidden attributes to the
      // DOM and not try to actually trap, as trapping can mess with the
      // live DOM and isn't just isolated to the cloned DOM.
      (el, { expression, modifiers }, { evaluate }) => {
        if (modifiers.includes("inert") && evaluate(expression))
          setInert(el);
      }
    ));
  }
  function setInert(el) {
    let undos = [];
    crawlSiblingsUp(el, (sibling) => {
      let cache = sibling.hasAttribute("aria-hidden");
      sibling.setAttribute("aria-hidden", "true");
      undos.push(() => cache || sibling.removeAttribute("aria-hidden"));
    });
    return () => {
      while (undos.length)
        undos.pop()();
    };
  }
  function crawlSiblingsUp(el, callback) {
    if (el.isSameNode(document.body) || !el.parentNode)
      return;
    Array.from(el.parentNode.children).forEach((sibling) => {
      if (sibling.isSameNode(el)) {
        crawlSiblingsUp(el.parentNode, callback);
      } else {
        callback(sibling);
      }
    });
  }
  function disableScrolling() {
    let overflow = document.documentElement.style.overflow;
    let paddingRight = document.documentElement.style.paddingRight;
    let scrollbarWidth = window.innerWidth - document.documentElement.clientWidth;
    document.documentElement.style.overflow = "hidden";
    document.documentElement.style.paddingRight = `${scrollbarWidth}px`;
    return () => {
      document.documentElement.style.overflow = overflow;
      document.documentElement.style.paddingRight = paddingRight;
    };
  }

  // packages/focus/builds/module.js
  var module_default$3 = src_default$3;
  /*! Bundled license information:

  tabbable/dist/index.esm.js:
    (*!
    * tabbable 5.3.3
    * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
    *)

  focus-trap/dist/focus-trap.esm.js:
    (*!
    * focus-trap 6.9.4
    * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
    *)
  */

  // packages/intersect/src/index.js
  function src_default$2(Alpine) {
    Alpine.directive("intersect", (el, { value, expression, modifiers }, { evaluateLater, cleanup }) => {
      let evaluate = evaluateLater(expression);
      let options = {
        rootMargin: getRootMargin(modifiers),
        threshold: getThreshold(modifiers)
      };
      let observer = new IntersectionObserver((entries) => {
        entries.forEach((entry) => {
          if (entry.isIntersecting === (value === "leave"))
            return;
          evaluate();
          modifiers.includes("once") && observer.disconnect();
        });
      }, options);
      observer.observe(el);
      cleanup(() => {
        observer.disconnect();
      });
    });
  }
  function getThreshold(modifiers) {
    if (modifiers.includes("full"))
      return 0.99;
    if (modifiers.includes("half"))
      return 0.5;
    if (!modifiers.includes("threshold"))
      return 0;
    let threshold = modifiers[modifiers.indexOf("threshold") + 1];
    if (threshold === "100")
      return 1;
    if (threshold === "0")
      return 0;
    return Number(`.${threshold}`);
  }
  function getLengthValue(rawValue) {
    let match = rawValue.match(/^(-?[0-9]+)(px|%)?$/);
    return match ? match[1] + (match[2] || "px") : void 0;
  }
  function getRootMargin(modifiers) {
    const key = "margin";
    const fallback = "0px 0px 0px 0px";
    const index = modifiers.indexOf(key);
    if (index === -1)
      return fallback;
    let values = [];
    for (let i = 1; i < 5; i++) {
      values.push(getLengthValue(modifiers[index + i] || ""));
    }
    values = values.filter((v) => v !== void 0);
    return values.length ? values.join(" ").trim() : fallback;
  }

  // packages/intersect/builds/module.js
  var module_default$2 = src_default$2;

  // packages/persist/src/index.js
  function src_default$1(Alpine) {
    let persist = () => {
      let alias;
      let storage;
      try {
        storage = localStorage;
      } catch (e) {
        console.error(e);
        console.warn("Alpine: $persist is using temporary storage since localStorage is unavailable.");
        let dummy = /* @__PURE__ */ new Map();
        storage = {
          getItem: dummy.get.bind(dummy),
          setItem: dummy.set.bind(dummy)
        };
      }
      return Alpine.interceptor((initialValue, getter, setter, path, key) => {
        let lookup = alias || `_x_${path}`;
        let initial = storageHas(lookup, storage) ? storageGet(lookup, storage) : initialValue;
        setter(initial);
        Alpine.effect(() => {
          let value = getter();
          storageSet(lookup, value, storage);
          setter(value);
        });
        return initial;
      }, (func) => {
        func.as = (key) => {
          alias = key;
          return func;
        }, func.using = (target) => {
          storage = target;
          return func;
        };
      });
    };
    Object.defineProperty(Alpine, "$persist", { get: () => persist() });
    Alpine.magic("persist", persist);
    Alpine.persist = (key, { get, set }, storage = localStorage) => {
      let initial = storageHas(key, storage) ? storageGet(key, storage) : get();
      set(initial);
      Alpine.effect(() => {
        let value = get();
        storageSet(key, value, storage);
        set(value);
      });
    };
  }
  function storageHas(key, storage) {
    return storage.getItem(key) !== null;
  }
  function storageGet(key, storage) {
    return JSON.parse(storage.getItem(key, storage));
  }
  function storageSet(key, value, storage) {
    storage.setItem(key, JSON.stringify(value));
  }

  // packages/persist/builds/module.js
  var module_default$1 = src_default$1;

  // packages/alpinejs/src/scheduler.js
  var flushPending = false;
  var flushing = false;
  var queue = [];
  var lastFlushedIndex = -1;
  function scheduler(callback) {
    queueJob(callback);
  }
  function queueJob(job) {
    if (!queue.includes(job))
      queue.push(job);
    queueFlush();
  }
  function dequeueJob(job) {
    let index = queue.indexOf(job);
    if (index !== -1 && index > lastFlushedIndex)
      queue.splice(index, 1);
  }
  function queueFlush() {
    if (!flushing && !flushPending) {
      flushPending = true;
      queueMicrotask(flushJobs);
    }
  }
  function flushJobs() {
    flushPending = false;
    flushing = true;
    for (let i = 0; i < queue.length; i++) {
      queue[i]();
      lastFlushedIndex = i;
    }
    queue.length = 0;
    lastFlushedIndex = -1;
    flushing = false;
  }

  // packages/alpinejs/src/reactivity.js
  var reactive;
  var effect;
  var release;
  var raw;
  var shouldSchedule = true;
  function disableEffectScheduling(callback) {
    shouldSchedule = false;
    callback();
    shouldSchedule = true;
  }
  function setReactivityEngine(engine) {
    reactive = engine.reactive;
    release = engine.release;
    effect = (callback) => engine.effect(callback, { scheduler: (task) => {
      if (shouldSchedule) {
        scheduler(task);
      } else {
        task();
      }
    } });
    raw = engine.raw;
  }
  function overrideEffect(override) {
    effect = override;
  }
  function elementBoundEffect(el) {
    let cleanup2 = () => {
    };
    let wrappedEffect = (callback) => {
      let effectReference = effect(callback);
      if (!el._x_effects) {
        el._x_effects = /* @__PURE__ */ new Set();
        el._x_runEffects = () => {
          el._x_effects.forEach((i) => i());
        };
      }
      el._x_effects.add(effectReference);
      cleanup2 = () => {
        if (effectReference === void 0)
          return;
        el._x_effects.delete(effectReference);
        release(effectReference);
      };
      return effectReference;
    };
    return [wrappedEffect, () => {
      cleanup2();
    }];
  }
  function watch(getter, callback) {
    let firstTime = true;
    let oldValue;
    let effectReference = effect(() => {
      let value = getter();
      JSON.stringify(value);
      if (!firstTime) {
        queueMicrotask(() => {
          callback(value, oldValue);
          oldValue = value;
        });
      } else {
        oldValue = value;
      }
      firstTime = false;
    });
    return () => release(effectReference);
  }

  // packages/alpinejs/src/utils/dispatch.js
  function dispatch(el, name, detail = {}) {
    el.dispatchEvent(
      new CustomEvent(name, {
        detail,
        bubbles: true,
        // Allows events to pass the shadow DOM barrier.
        composed: true,
        cancelable: true
      })
    );
  }

  // packages/alpinejs/src/utils/walk.js
  function walk(el, callback) {
    if (typeof ShadowRoot === "function" && el instanceof ShadowRoot) {
      Array.from(el.children).forEach((el2) => walk(el2, callback));
      return;
    }
    let skip = false;
    callback(el, () => skip = true);
    if (skip)
      return;
    let node = el.firstElementChild;
    while (node) {
      walk(node, callback);
      node = node.nextElementSibling;
    }
  }

  // packages/alpinejs/src/utils/warn.js
  function warn(message, ...args) {
    console.warn(`Alpine Warning: ${message}`, ...args);
  }

  // packages/alpinejs/src/lifecycle.js
  var started = false;
  function start() {
    if (started)
      warn("Alpine has already been initialized on this page. Calling Alpine.start() more than once can cause problems.");
    started = true;
    if (!document.body)
      warn("Unable to initialize. Trying to load Alpine before `<body>` is available. Did you forget to add `defer` in Alpine's `<script>` tag?");
    dispatch(document, "alpine:init");
    dispatch(document, "alpine:initializing");
    startObservingMutations();
    onElAdded((el) => initTree(el, walk));
    onElRemoved((el) => destroyTree(el));
    onAttributesAdded((el, attrs) => {
      directives(el, attrs).forEach((handle) => handle());
    });
    let outNestedComponents = (el) => !closestRoot(el.parentElement, true);
    Array.from(document.querySelectorAll(allSelectors().join(","))).filter(outNestedComponents).forEach((el) => {
      initTree(el);
    });
    dispatch(document, "alpine:initialized");
  }
  var rootSelectorCallbacks = [];
  var initSelectorCallbacks = [];
  function rootSelectors() {
    return rootSelectorCallbacks.map((fn) => fn());
  }
  function allSelectors() {
    return rootSelectorCallbacks.concat(initSelectorCallbacks).map((fn) => fn());
  }
  function addRootSelector(selectorCallback) {
    rootSelectorCallbacks.push(selectorCallback);
  }
  function addInitSelector(selectorCallback) {
    initSelectorCallbacks.push(selectorCallback);
  }
  function closestRoot(el, includeInitSelectors = false) {
    return findClosest(el, (element) => {
      const selectors = includeInitSelectors ? allSelectors() : rootSelectors();
      if (selectors.some((selector) => element.matches(selector)))
        return true;
    });
  }
  function findClosest(el, callback) {
    if (!el)
      return;
    if (callback(el))
      return el;
    if (el._x_teleportBack)
      el = el._x_teleportBack;
    if (!el.parentElement)
      return;
    return findClosest(el.parentElement, callback);
  }
  function isRoot(el) {
    return rootSelectors().some((selector) => el.matches(selector));
  }
  var initInterceptors = [];
  function interceptInit(callback) {
    initInterceptors.push(callback);
  }
  function initTree(el, walker = walk, intercept = () => {
  }) {
    deferHandlingDirectives(() => {
      walker(el, (el2, skip) => {
        intercept(el2, skip);
        initInterceptors.forEach((i) => i(el2, skip));
        directives(el2, el2.attributes).forEach((handle) => handle());
        el2._x_ignore && skip();
      });
    });
  }
  function destroyTree(root) {
    walk(root, (el) => {
      cleanupAttributes(el);
      cleanupElement(el);
    });
  }

  // packages/alpinejs/src/mutation.js
  var onAttributeAddeds = [];
  var onElRemoveds = [];
  var onElAddeds = [];
  function onElAdded(callback) {
    onElAddeds.push(callback);
  }
  function onElRemoved(el, callback) {
    if (typeof callback === "function") {
      if (!el._x_cleanups)
        el._x_cleanups = [];
      el._x_cleanups.push(callback);
    } else {
      callback = el;
      onElRemoveds.push(callback);
    }
  }
  function onAttributesAdded(callback) {
    onAttributeAddeds.push(callback);
  }
  function onAttributeRemoved(el, name, callback) {
    if (!el._x_attributeCleanups)
      el._x_attributeCleanups = {};
    if (!el._x_attributeCleanups[name])
      el._x_attributeCleanups[name] = [];
    el._x_attributeCleanups[name].push(callback);
  }
  function cleanupAttributes(el, names) {
    if (!el._x_attributeCleanups)
      return;
    Object.entries(el._x_attributeCleanups).forEach(([name, value]) => {
      if (names === void 0 || names.includes(name)) {
        value.forEach((i) => i());
        delete el._x_attributeCleanups[name];
      }
    });
  }
  function cleanupElement(el) {
    if (el._x_cleanups) {
      while (el._x_cleanups.length)
        el._x_cleanups.pop()();
    }
  }
  var observer = new MutationObserver(onMutate);
  var currentlyObserving = false;
  function startObservingMutations() {
    observer.observe(document, { subtree: true, childList: true, attributes: true, attributeOldValue: true });
    currentlyObserving = true;
  }
  function stopObservingMutations() {
    flushObserver();
    observer.disconnect();
    currentlyObserving = false;
  }
  var queuedMutations = [];
  function flushObserver() {
    let records = observer.takeRecords();
    queuedMutations.push(() => records.length > 0 && onMutate(records));
    let queueLengthWhenTriggered = queuedMutations.length;
    queueMicrotask(() => {
      if (queuedMutations.length === queueLengthWhenTriggered) {
        while (queuedMutations.length > 0)
          queuedMutations.shift()();
      }
    });
  }
  function mutateDom(callback) {
    if (!currentlyObserving)
      return callback();
    stopObservingMutations();
    let result = callback();
    startObservingMutations();
    return result;
  }
  var isCollecting = false;
  var deferredMutations = [];
  function deferMutations() {
    isCollecting = true;
  }
  function flushAndStopDeferringMutations() {
    isCollecting = false;
    onMutate(deferredMutations);
    deferredMutations = [];
  }
  function onMutate(mutations) {
    if (isCollecting) {
      deferredMutations = deferredMutations.concat(mutations);
      return;
    }
    let addedNodes = /* @__PURE__ */ new Set();
    let removedNodes = /* @__PURE__ */ new Set();
    let addedAttributes = /* @__PURE__ */ new Map();
    let removedAttributes = /* @__PURE__ */ new Map();
    for (let i = 0; i < mutations.length; i++) {
      if (mutations[i].target._x_ignoreMutationObserver)
        continue;
      if (mutations[i].type === "childList") {
        mutations[i].addedNodes.forEach((node) => node.nodeType === 1 && addedNodes.add(node));
        mutations[i].removedNodes.forEach((node) => node.nodeType === 1 && removedNodes.add(node));
      }
      if (mutations[i].type === "attributes") {
        let el = mutations[i].target;
        let name = mutations[i].attributeName;
        let oldValue = mutations[i].oldValue;
        let add2 = () => {
          if (!addedAttributes.has(el))
            addedAttributes.set(el, []);
          addedAttributes.get(el).push({ name, value: el.getAttribute(name) });
        };
        let remove = () => {
          if (!removedAttributes.has(el))
            removedAttributes.set(el, []);
          removedAttributes.get(el).push(name);
        };
        if (el.hasAttribute(name) && oldValue === null) {
          add2();
        } else if (el.hasAttribute(name)) {
          remove();
          add2();
        } else {
          remove();
        }
      }
    }
    removedAttributes.forEach((attrs, el) => {
      cleanupAttributes(el, attrs);
    });
    addedAttributes.forEach((attrs, el) => {
      onAttributeAddeds.forEach((i) => i(el, attrs));
    });
    for (let node of removedNodes) {
      if (addedNodes.has(node))
        continue;
      onElRemoveds.forEach((i) => i(node));
      destroyTree(node);
    }
    addedNodes.forEach((node) => {
      node._x_ignoreSelf = true;
      node._x_ignore = true;
    });
    for (let node of addedNodes) {
      if (removedNodes.has(node))
        continue;
      if (!node.isConnected)
        continue;
      delete node._x_ignoreSelf;
      delete node._x_ignore;
      onElAddeds.forEach((i) => i(node));
      node._x_ignore = true;
      node._x_ignoreSelf = true;
    }
    addedNodes.forEach((node) => {
      delete node._x_ignoreSelf;
      delete node._x_ignore;
    });
    addedNodes = null;
    removedNodes = null;
    addedAttributes = null;
    removedAttributes = null;
  }

  // packages/alpinejs/src/scope.js
  function scope(node) {
    return mergeProxies(closestDataStack(node));
  }
  function addScopeToNode(node, data2, referenceNode) {
    node._x_dataStack = [data2, ...closestDataStack(referenceNode || node)];
    return () => {
      node._x_dataStack = node._x_dataStack.filter((i) => i !== data2);
    };
  }
  function closestDataStack(node) {
    if (node._x_dataStack)
      return node._x_dataStack;
    if (typeof ShadowRoot === "function" && node instanceof ShadowRoot) {
      return closestDataStack(node.host);
    }
    if (!node.parentNode) {
      return [];
    }
    return closestDataStack(node.parentNode);
  }
  function mergeProxies(objects) {
    return new Proxy({ objects }, mergeProxyTrap);
  }
  var mergeProxyTrap = {
    ownKeys({ objects }) {
      return Array.from(
        new Set(objects.flatMap((i) => Object.keys(i)))
      );
    },
    has({ objects }, name) {
      if (name == Symbol.unscopables)
        return false;
      return objects.some(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      );
    },
    get({ objects }, name, thisProxy) {
      if (name == "toJSON")
        return collapseProxies;
      return Reflect.get(
        objects.find(
          (obj) => Object.prototype.hasOwnProperty.call(obj, name)
        ) || {},
        name,
        thisProxy
      );
    },
    set({ objects }, name, value, thisProxy) {
      const target = objects.find(
        (obj) => Object.prototype.hasOwnProperty.call(obj, name)
      ) || objects[objects.length - 1];
      const descriptor = Object.getOwnPropertyDescriptor(target, name);
      if (descriptor?.set && descriptor?.get)
        return Reflect.set(target, name, value, thisProxy);
      return Reflect.set(target, name, value);
    }
  };
  function collapseProxies() {
    let keys = Reflect.ownKeys(this);
    return keys.reduce((acc, key) => {
      acc[key] = Reflect.get(this, key);
      return acc;
    }, {});
  }

  // packages/alpinejs/src/interceptor.js
  function initInterceptors2(data2) {
    let isObject2 = (val) => typeof val === "object" && !Array.isArray(val) && val !== null;
    let recurse = (obj, basePath = "") => {
      Object.entries(Object.getOwnPropertyDescriptors(obj)).forEach(([key, { value, enumerable }]) => {
        if (enumerable === false || value === void 0)
          return;
        let path = basePath === "" ? key : `${basePath}.${key}`;
        if (typeof value === "object" && value !== null && value._x_interceptor) {
          obj[key] = value.initialize(data2, path, key);
        } else {
          if (isObject2(value) && value !== obj && !(value instanceof Element)) {
            recurse(value, path);
          }
        }
      });
    };
    return recurse(data2);
  }
  function interceptor(callback, mutateObj = () => {
  }) {
    let obj = {
      initialValue: void 0,
      _x_interceptor: true,
      initialize(data2, path, key) {
        return callback(this.initialValue, () => get(data2, path), (value) => set(data2, path, value), path, key);
      }
    };
    mutateObj(obj);
    return (initialValue) => {
      if (typeof initialValue === "object" && initialValue !== null && initialValue._x_interceptor) {
        let initialize = obj.initialize.bind(obj);
        obj.initialize = (data2, path, key) => {
          let innerValue = initialValue.initialize(data2, path, key);
          obj.initialValue = innerValue;
          return initialize(data2, path, key);
        };
      } else {
        obj.initialValue = initialValue;
      }
      return obj;
    };
  }
  function get(obj, path) {
    return path.split(".").reduce((carry, segment) => carry[segment], obj);
  }
  function set(obj, path, value) {
    if (typeof path === "string")
      path = path.split(".");
    if (path.length === 1)
      obj[path[0]] = value;
    else if (path.length === 0)
      throw error;
    else {
      if (obj[path[0]])
        return set(obj[path[0]], path.slice(1), value);
      else {
        obj[path[0]] = {};
        return set(obj[path[0]], path.slice(1), value);
      }
    }
  }

  // packages/alpinejs/src/magics.js
  var magics = {};
  function magic(name, callback) {
    magics[name] = callback;
  }
  function injectMagics(obj, el) {
    Object.entries(magics).forEach(([name, callback]) => {
      let memoizedUtilities = null;
      function getUtilities() {
        if (memoizedUtilities) {
          return memoizedUtilities;
        } else {
          let [utilities, cleanup2] = getElementBoundUtilities(el);
          memoizedUtilities = { interceptor, ...utilities };
          onElRemoved(el, cleanup2);
          return memoizedUtilities;
        }
      }
      Object.defineProperty(obj, `$${name}`, {
        get() {
          return callback(el, getUtilities());
        },
        enumerable: false
      });
    });
    return obj;
  }

  // packages/alpinejs/src/utils/error.js
  function tryCatch(el, expression, callback, ...args) {
    try {
      return callback(...args);
    } catch (e) {
      handleError(e, el, expression);
    }
  }
  function handleError(error2, el, expression = void 0) {
    error2 = Object.assign(
      error2 ?? { message: "No error message given." },
      { el, expression }
    );
    console.warn(`Alpine Expression Error: ${error2.message}

${expression ? 'Expression: "' + expression + '"\n\n' : ""}`, el);
    setTimeout(() => {
      throw error2;
    }, 0);
  }

  // packages/alpinejs/src/evaluator.js
  var shouldAutoEvaluateFunctions = true;
  function dontAutoEvaluateFunctions(callback) {
    let cache = shouldAutoEvaluateFunctions;
    shouldAutoEvaluateFunctions = false;
    let result = callback();
    shouldAutoEvaluateFunctions = cache;
    return result;
  }
  function evaluate(el, expression, extras = {}) {
    let result;
    evaluateLater(el, expression)((value) => result = value, extras);
    return result;
  }
  function evaluateLater(...args) {
    return theEvaluatorFunction(...args);
  }
  var theEvaluatorFunction = normalEvaluator;
  function setEvaluator(newEvaluator) {
    theEvaluatorFunction = newEvaluator;
  }
  function normalEvaluator(el, expression) {
    let overriddenMagics = {};
    injectMagics(overriddenMagics, el);
    let dataStack = [overriddenMagics, ...closestDataStack(el)];
    let evaluator = typeof expression === "function" ? generateEvaluatorFromFunction(dataStack, expression) : generateEvaluatorFromString(dataStack, expression, el);
    return tryCatch.bind(null, el, expression, evaluator);
  }
  function generateEvaluatorFromFunction(dataStack, func) {
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      let result = func.apply(mergeProxies([scope2, ...dataStack]), params);
      runIfTypeOfFunction(receiver, result);
    };
  }
  var evaluatorMemo = {};
  function generateFunctionFromString(expression, el) {
    if (evaluatorMemo[expression]) {
      return evaluatorMemo[expression];
    }
    let AsyncFunction = Object.getPrototypeOf(async function() {
    }).constructor;
    let rightSideSafeExpression = /^[\n\s]*if.*\(.*\)/.test(expression.trim()) || /^(let|const)\s/.test(expression.trim()) ? `(async()=>{ ${expression} })()` : expression;
    const safeAsyncFunction = () => {
      try {
        let func2 = new AsyncFunction(
          ["__self", "scope"],
          `with (scope) { __self.result = ${rightSideSafeExpression} }; __self.finished = true; return __self.result;`
        );
        Object.defineProperty(func2, "name", {
          value: `[Alpine] ${expression}`
        });
        return func2;
      } catch (error2) {
        handleError(error2, el, expression);
        return Promise.resolve();
      }
    };
    let func = safeAsyncFunction();
    evaluatorMemo[expression] = func;
    return func;
  }
  function generateEvaluatorFromString(dataStack, expression, el) {
    let func = generateFunctionFromString(expression, el);
    return (receiver = () => {
    }, { scope: scope2 = {}, params = [] } = {}) => {
      func.result = void 0;
      func.finished = false;
      let completeScope = mergeProxies([scope2, ...dataStack]);
      if (typeof func === "function") {
        let promise = func(func, completeScope).catch((error2) => handleError(error2, el, expression));
        if (func.finished) {
          runIfTypeOfFunction(receiver, func.result, completeScope, params, el);
          func.result = void 0;
        } else {
          promise.then((result) => {
            runIfTypeOfFunction(receiver, result, completeScope, params, el);
          }).catch((error2) => handleError(error2, el, expression)).finally(() => func.result = void 0);
        }
      }
    };
  }
  function runIfTypeOfFunction(receiver, value, scope2, params, el) {
    if (shouldAutoEvaluateFunctions && typeof value === "function") {
      let result = value.apply(scope2, params);
      if (result instanceof Promise) {
        result.then((i) => runIfTypeOfFunction(receiver, i, scope2, params)).catch((error2) => handleError(error2, el, value));
      } else {
        receiver(result);
      }
    } else if (typeof value === "object" && value instanceof Promise) {
      value.then((i) => receiver(i));
    } else {
      receiver(value);
    }
  }

  // packages/alpinejs/src/directives.js
  var prefixAsString = "x-";
  function prefix(subject = "") {
    return prefixAsString + subject;
  }
  function setPrefix(newPrefix) {
    prefixAsString = newPrefix;
  }
  var directiveHandlers = {};
  function directive(name, callback) {
    directiveHandlers[name] = callback;
    return {
      before(directive2) {
        if (!directiveHandlers[directive2]) {
          console.warn(String.raw`Cannot find directive \`${directive2}\`. \`${name}\` will use the default order of execution`);
          return;
        }
        const pos = directiveOrder.indexOf(directive2);
        directiveOrder.splice(pos >= 0 ? pos : directiveOrder.indexOf("DEFAULT"), 0, name);
      }
    };
  }
  function directives(el, attributes, originalAttributeOverride) {
    attributes = Array.from(attributes);
    if (el._x_virtualDirectives) {
      let vAttributes = Object.entries(el._x_virtualDirectives).map(([name, value]) => ({ name, value }));
      let staticAttributes = attributesOnly(vAttributes);
      vAttributes = vAttributes.map((attribute) => {
        if (staticAttributes.find((attr) => attr.name === attribute.name)) {
          return {
            name: `x-bind:${attribute.name}`,
            value: `"${attribute.value}"`
          };
        }
        return attribute;
      });
      attributes = attributes.concat(vAttributes);
    }
    let transformedAttributeMap = {};
    let directives2 = attributes.map(toTransformedAttributes((newName, oldName) => transformedAttributeMap[newName] = oldName)).filter(outNonAlpineAttributes).map(toParsedDirectives(transformedAttributeMap, originalAttributeOverride)).sort(byPriority);
    return directives2.map((directive2) => {
      return getDirectiveHandler(el, directive2);
    });
  }
  function attributesOnly(attributes) {
    return Array.from(attributes).map(toTransformedAttributes()).filter((attr) => !outNonAlpineAttributes(attr));
  }
  var isDeferringHandlers = false;
  var directiveHandlerStacks = /* @__PURE__ */ new Map();
  var currentHandlerStackKey = Symbol();
  function deferHandlingDirectives(callback) {
    isDeferringHandlers = true;
    let key = Symbol();
    currentHandlerStackKey = key;
    directiveHandlerStacks.set(key, []);
    let flushHandlers = () => {
      while (directiveHandlerStacks.get(key).length)
        directiveHandlerStacks.get(key).shift()();
      directiveHandlerStacks.delete(key);
    };
    let stopDeferring = () => {
      isDeferringHandlers = false;
      flushHandlers();
    };
    callback(flushHandlers);
    stopDeferring();
  }
  function getElementBoundUtilities(el) {
    let cleanups = [];
    let cleanup2 = (callback) => cleanups.push(callback);
    let [effect3, cleanupEffect] = elementBoundEffect(el);
    cleanups.push(cleanupEffect);
    let utilities = {
      Alpine: alpine_default,
      effect: effect3,
      cleanup: cleanup2,
      evaluateLater: evaluateLater.bind(evaluateLater, el),
      evaluate: evaluate.bind(evaluate, el)
    };
    let doCleanup = () => cleanups.forEach((i) => i());
    return [utilities, doCleanup];
  }
  function getDirectiveHandler(el, directive2) {
    let noop = () => {
    };
    let handler4 = directiveHandlers[directive2.type] || noop;
    let [utilities, cleanup2] = getElementBoundUtilities(el);
    onAttributeRemoved(el, directive2.original, cleanup2);
    let fullHandler = () => {
      if (el._x_ignore || el._x_ignoreSelf)
        return;
      handler4.inline && handler4.inline(el, directive2, utilities);
      handler4 = handler4.bind(handler4, el, directive2, utilities);
      isDeferringHandlers ? directiveHandlerStacks.get(currentHandlerStackKey).push(handler4) : handler4();
    };
    fullHandler.runCleanups = cleanup2;
    return fullHandler;
  }
  var startingWith = (subject, replacement) => ({ name, value }) => {
    if (name.startsWith(subject))
      name = name.replace(subject, replacement);
    return { name, value };
  };
  var into = (i) => i;
  function toTransformedAttributes(callback = () => {
  }) {
    return ({ name, value }) => {
      let { name: newName, value: newValue } = attributeTransformers.reduce((carry, transform) => {
        return transform(carry);
      }, { name, value });
      if (newName !== name)
        callback(newName, name);
      return { name: newName, value: newValue };
    };
  }
  var attributeTransformers = [];
  function mapAttributes(callback) {
    attributeTransformers.push(callback);
  }
  function outNonAlpineAttributes({ name }) {
    return alpineAttributeRegex().test(name);
  }
  var alpineAttributeRegex = () => new RegExp(`^${prefixAsString}([^:^.]+)\\b`);
  function toParsedDirectives(transformedAttributeMap, originalAttributeOverride) {
    return ({ name, value }) => {
      let typeMatch = name.match(alpineAttributeRegex());
      let valueMatch = name.match(/:([a-zA-Z0-9\-_:]+)/);
      let modifiers = name.match(/\.[^.\]]+(?=[^\]]*$)/g) || [];
      let original = originalAttributeOverride || transformedAttributeMap[name] || name;
      return {
        type: typeMatch ? typeMatch[1] : null,
        value: valueMatch ? valueMatch[1] : null,
        modifiers: modifiers.map((i) => i.replace(".", "")),
        expression: value,
        original
      };
    };
  }
  var DEFAULT = "DEFAULT";
  var directiveOrder = [
    "ignore",
    "ref",
    "data",
    "id",
    "anchor",
    "bind",
    "init",
    "for",
    "model",
    "modelable",
    "transition",
    "show",
    "if",
    DEFAULT,
    "teleport"
  ];
  function byPriority(a, b) {
    let typeA = directiveOrder.indexOf(a.type) === -1 ? DEFAULT : a.type;
    let typeB = directiveOrder.indexOf(b.type) === -1 ? DEFAULT : b.type;
    return directiveOrder.indexOf(typeA) - directiveOrder.indexOf(typeB);
  }

  // packages/alpinejs/src/nextTick.js
  var tickStack = [];
  var isHolding = false;
  function nextTick(callback = () => {
  }) {
    queueMicrotask(() => {
      isHolding || setTimeout(() => {
        releaseNextTicks();
      });
    });
    return new Promise((res) => {
      tickStack.push(() => {
        callback();
        res();
      });
    });
  }
  function releaseNextTicks() {
    isHolding = false;
    while (tickStack.length)
      tickStack.shift()();
  }
  function holdNextTicks() {
    isHolding = true;
  }

  // packages/alpinejs/src/utils/classes.js
  function setClasses(el, value) {
    if (Array.isArray(value)) {
      return setClassesFromString(el, value.join(" "));
    } else if (typeof value === "object" && value !== null) {
      return setClassesFromObject(el, value);
    } else if (typeof value === "function") {
      return setClasses(el, value());
    }
    return setClassesFromString(el, value);
  }
  function setClassesFromString(el, classString) {
    let missingClasses = (classString2) => classString2.split(" ").filter((i) => !el.classList.contains(i)).filter(Boolean);
    let addClassesAndReturnUndo = (classes) => {
      el.classList.add(...classes);
      return () => {
        el.classList.remove(...classes);
      };
    };
    classString = classString === true ? classString = "" : classString || "";
    return addClassesAndReturnUndo(missingClasses(classString));
  }
  function setClassesFromObject(el, classObject) {
    let split = (classString) => classString.split(" ").filter(Boolean);
    let forAdd = Object.entries(classObject).flatMap(([classString, bool]) => bool ? split(classString) : false).filter(Boolean);
    let forRemove = Object.entries(classObject).flatMap(([classString, bool]) => !bool ? split(classString) : false).filter(Boolean);
    let added = [];
    let removed = [];
    forRemove.forEach((i) => {
      if (el.classList.contains(i)) {
        el.classList.remove(i);
        removed.push(i);
      }
    });
    forAdd.forEach((i) => {
      if (!el.classList.contains(i)) {
        el.classList.add(i);
        added.push(i);
      }
    });
    return () => {
      removed.forEach((i) => el.classList.add(i));
      added.forEach((i) => el.classList.remove(i));
    };
  }

  // packages/alpinejs/src/utils/styles.js
  function setStyles(el, value) {
    if (typeof value === "object" && value !== null) {
      return setStylesFromObject(el, value);
    }
    return setStylesFromString(el, value);
  }
  function setStylesFromObject(el, value) {
    let previousStyles = {};
    Object.entries(value).forEach(([key, value2]) => {
      previousStyles[key] = el.style[key];
      if (!key.startsWith("--")) {
        key = kebabCase(key);
      }
      el.style.setProperty(key, value2);
    });
    setTimeout(() => {
      if (el.style.length === 0) {
        el.removeAttribute("style");
      }
    });
    return () => {
      setStyles(el, previousStyles);
    };
  }
  function setStylesFromString(el, value) {
    let cache = el.getAttribute("style", value);
    el.setAttribute("style", value);
    return () => {
      el.setAttribute("style", cache || "");
    };
  }
  function kebabCase(subject) {
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  }

  // packages/alpinejs/src/utils/once.js
  function once(callback, fallback = () => {
  }) {
    let called = false;
    return function() {
      if (!called) {
        called = true;
        callback.apply(this, arguments);
      } else {
        fallback.apply(this, arguments);
      }
    };
  }

  // packages/alpinejs/src/directives/x-transition.js
  directive("transition", (el, { value, modifiers, expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "function")
      expression = evaluate2(expression);
    if (expression === false)
      return;
    if (!expression || typeof expression === "boolean") {
      registerTransitionsFromHelper(el, modifiers, value);
    } else {
      registerTransitionsFromClassString(el, expression, value);
    }
  });
  function registerTransitionsFromClassString(el, classString, stage) {
    registerTransitionObject(el, setClasses, "");
    let directiveStorageMap = {
      "enter": (classes) => {
        el._x_transition.enter.during = classes;
      },
      "enter-start": (classes) => {
        el._x_transition.enter.start = classes;
      },
      "enter-end": (classes) => {
        el._x_transition.enter.end = classes;
      },
      "leave": (classes) => {
        el._x_transition.leave.during = classes;
      },
      "leave-start": (classes) => {
        el._x_transition.leave.start = classes;
      },
      "leave-end": (classes) => {
        el._x_transition.leave.end = classes;
      }
    };
    directiveStorageMap[stage](classString);
  }
  function registerTransitionsFromHelper(el, modifiers, stage) {
    registerTransitionObject(el, setStyles);
    let doesntSpecify = !modifiers.includes("in") && !modifiers.includes("out") && !stage;
    let transitioningIn = doesntSpecify || modifiers.includes("in") || ["enter"].includes(stage);
    let transitioningOut = doesntSpecify || modifiers.includes("out") || ["leave"].includes(stage);
    if (modifiers.includes("in") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index < modifiers.indexOf("out"));
    }
    if (modifiers.includes("out") && !doesntSpecify) {
      modifiers = modifiers.filter((i, index) => index > modifiers.indexOf("out"));
    }
    let wantsAll = !modifiers.includes("opacity") && !modifiers.includes("scale");
    let wantsOpacity = wantsAll || modifiers.includes("opacity");
    let wantsScale = wantsAll || modifiers.includes("scale");
    let opacityValue = wantsOpacity ? 0 : 1;
    let scaleValue = wantsScale ? modifierValue(modifiers, "scale", 95) / 100 : 1;
    let delay = modifierValue(modifiers, "delay", 0) / 1e3;
    let origin = modifierValue(modifiers, "origin", "center");
    let property = "opacity, transform";
    let durationIn = modifierValue(modifiers, "duration", 150) / 1e3;
    let durationOut = modifierValue(modifiers, "duration", 75) / 1e3;
    let easing = `cubic-bezier(0.4, 0.0, 0.2, 1)`;
    if (transitioningIn) {
      el._x_transition.enter.during = {
        transformOrigin: origin,
        transitionDelay: `${delay}s`,
        transitionProperty: property,
        transitionDuration: `${durationIn}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.enter.start = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
      el._x_transition.enter.end = {
        opacity: 1,
        transform: `scale(1)`
      };
    }
    if (transitioningOut) {
      el._x_transition.leave.during = {
        transformOrigin: origin,
        transitionDelay: `${delay}s`,
        transitionProperty: property,
        transitionDuration: `${durationOut}s`,
        transitionTimingFunction: easing
      };
      el._x_transition.leave.start = {
        opacity: 1,
        transform: `scale(1)`
      };
      el._x_transition.leave.end = {
        opacity: opacityValue,
        transform: `scale(${scaleValue})`
      };
    }
  }
  function registerTransitionObject(el, setFunction, defaultValue = {}) {
    if (!el._x_transition)
      el._x_transition = {
        enter: { during: defaultValue, start: defaultValue, end: defaultValue },
        leave: { during: defaultValue, start: defaultValue, end: defaultValue },
        in(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.enter.during,
            start: this.enter.start,
            end: this.enter.end
          }, before, after);
        },
        out(before = () => {
        }, after = () => {
        }) {
          transition(el, setFunction, {
            during: this.leave.during,
            start: this.leave.start,
            end: this.leave.end
          }, before, after);
        }
      };
  }
  window.Element.prototype._x_toggleAndCascadeWithTransitions = function(el, value, show, hide) {
    const nextTick2 = document.visibilityState === "visible" ? requestAnimationFrame : setTimeout;
    let clickAwayCompatibleShow = () => nextTick2(show);
    if (value) {
      if (el._x_transition && (el._x_transition.enter || el._x_transition.leave)) {
        el._x_transition.enter && (Object.entries(el._x_transition.enter.during).length || Object.entries(el._x_transition.enter.start).length || Object.entries(el._x_transition.enter.end).length) ? el._x_transition.in(show) : clickAwayCompatibleShow();
      } else {
        el._x_transition ? el._x_transition.in(show) : clickAwayCompatibleShow();
      }
      return;
    }
    el._x_hidePromise = el._x_transition ? new Promise((resolve, reject) => {
      el._x_transition.out(() => {
      }, () => resolve(hide));
      el._x_transitioning && el._x_transitioning.beforeCancel(() => reject({ isFromCancelledTransition: true }));
    }) : Promise.resolve(hide);
    queueMicrotask(() => {
      let closest = closestHide(el);
      if (closest) {
        if (!closest._x_hideChildren)
          closest._x_hideChildren = [];
        closest._x_hideChildren.push(el);
      } else {
        nextTick2(() => {
          let hideAfterChildren = (el2) => {
            let carry = Promise.all([
              el2._x_hidePromise,
              ...(el2._x_hideChildren || []).map(hideAfterChildren)
            ]).then(([i]) => i());
            delete el2._x_hidePromise;
            delete el2._x_hideChildren;
            return carry;
          };
          hideAfterChildren(el).catch((e) => {
            if (!e.isFromCancelledTransition)
              throw e;
          });
        });
      }
    });
  };
  function closestHide(el) {
    let parent = el.parentNode;
    if (!parent)
      return;
    return parent._x_hidePromise ? parent : closestHide(parent);
  }
  function transition(el, setFunction, { during, start: start2, end } = {}, before = () => {
  }, after = () => {
  }) {
    if (el._x_transitioning)
      el._x_transitioning.cancel();
    if (Object.keys(during).length === 0 && Object.keys(start2).length === 0 && Object.keys(end).length === 0) {
      before();
      after();
      return;
    }
    let undoStart, undoDuring, undoEnd;
    performTransition(el, {
      start() {
        undoStart = setFunction(el, start2);
      },
      during() {
        undoDuring = setFunction(el, during);
      },
      before,
      end() {
        undoStart();
        undoEnd = setFunction(el, end);
      },
      after,
      cleanup() {
        undoDuring();
        undoEnd();
      }
    });
  }
  function performTransition(el, stages) {
    let interrupted, reachedBefore, reachedEnd;
    let finish = once(() => {
      mutateDom(() => {
        interrupted = true;
        if (!reachedBefore)
          stages.before();
        if (!reachedEnd) {
          stages.end();
          releaseNextTicks();
        }
        stages.after();
        if (el.isConnected)
          stages.cleanup();
        delete el._x_transitioning;
      });
    });
    el._x_transitioning = {
      beforeCancels: [],
      beforeCancel(callback) {
        this.beforeCancels.push(callback);
      },
      cancel: once(function() {
        while (this.beforeCancels.length) {
          this.beforeCancels.shift()();
        }
        finish();
      }),
      finish
    };
    mutateDom(() => {
      stages.start();
      stages.during();
    });
    holdNextTicks();
    requestAnimationFrame(() => {
      if (interrupted)
        return;
      let duration = Number(getComputedStyle(el).transitionDuration.replace(/,.*/, "").replace("s", "")) * 1e3;
      let delay = Number(getComputedStyle(el).transitionDelay.replace(/,.*/, "").replace("s", "")) * 1e3;
      if (duration === 0)
        duration = Number(getComputedStyle(el).animationDuration.replace("s", "")) * 1e3;
      mutateDom(() => {
        stages.before();
      });
      reachedBefore = true;
      requestAnimationFrame(() => {
        if (interrupted)
          return;
        mutateDom(() => {
          stages.end();
        });
        releaseNextTicks();
        setTimeout(el._x_transitioning.finish, duration + delay);
        reachedEnd = true;
      });
    });
  }
  function modifierValue(modifiers, key, fallback) {
    if (modifiers.indexOf(key) === -1)
      return fallback;
    const rawValue = modifiers[modifiers.indexOf(key) + 1];
    if (!rawValue)
      return fallback;
    if (key === "scale") {
      if (isNaN(rawValue))
        return fallback;
    }
    if (key === "duration" || key === "delay") {
      let match = rawValue.match(/([0-9]+)ms/);
      if (match)
        return match[1];
    }
    if (key === "origin") {
      if (["top", "right", "left", "center", "bottom"].includes(modifiers[modifiers.indexOf(key) + 2])) {
        return [rawValue, modifiers[modifiers.indexOf(key) + 2]].join(" ");
      }
    }
    return rawValue;
  }

  // packages/alpinejs/src/clone.js
  var isCloning = false;
  function skipDuringClone(callback, fallback = () => {
  }) {
    return (...args) => isCloning ? fallback(...args) : callback(...args);
  }
  function onlyDuringClone(callback) {
    return (...args) => isCloning && callback(...args);
  }
  var interceptors = [];
  function interceptClone(callback) {
    interceptors.push(callback);
  }
  function cloneNode(from, to) {
    interceptors.forEach((i) => i(from, to));
    isCloning = true;
    dontRegisterReactiveSideEffects(() => {
      initTree(to, (el, callback) => {
        callback(el, () => {
        });
      });
    });
    isCloning = false;
  }
  var isCloningLegacy = false;
  function clone(oldEl, newEl) {
    if (!newEl._x_dataStack)
      newEl._x_dataStack = oldEl._x_dataStack;
    isCloning = true;
    isCloningLegacy = true;
    dontRegisterReactiveSideEffects(() => {
      cloneTree(newEl);
    });
    isCloning = false;
    isCloningLegacy = false;
  }
  function cloneTree(el) {
    let hasRunThroughFirstEl = false;
    let shallowWalker = (el2, callback) => {
      walk(el2, (el3, skip) => {
        if (hasRunThroughFirstEl && isRoot(el3))
          return skip();
        hasRunThroughFirstEl = true;
        callback(el3, skip);
      });
    };
    initTree(el, shallowWalker);
  }
  function dontRegisterReactiveSideEffects(callback) {
    let cache = effect;
    overrideEffect((callback2, el) => {
      let storedEffect = cache(callback2);
      release(storedEffect);
      return () => {
      };
    });
    callback();
    overrideEffect(cache);
  }

  // packages/alpinejs/src/utils/bind.js
  function bind(el, name, value, modifiers = []) {
    if (!el._x_bindings)
      el._x_bindings = reactive({});
    el._x_bindings[name] = value;
    name = modifiers.includes("camel") ? camelCase(name) : name;
    switch (name) {
      case "value":
        bindInputValue(el, value);
        break;
      case "style":
        bindStyles(el, value);
        break;
      case "class":
        bindClasses(el, value);
        break;
      case "selected":
      case "checked":
        bindAttributeAndProperty(el, name, value);
        break;
      default:
        bindAttribute(el, name, value);
        break;
    }
  }
  function bindInputValue(el, value) {
    if (el.type === "radio") {
      if (el.attributes.value === void 0) {
        el.value = value;
      }
      if (window.fromModel) {
        if (typeof value === "boolean") {
          el.checked = safeParseBoolean(el.value) === value;
        } else {
          el.checked = checkedAttrLooseCompare(el.value, value);
        }
      }
    } else if (el.type === "checkbox") {
      if (Number.isInteger(value)) {
        el.value = value;
      } else if (!Array.isArray(value) && typeof value !== "boolean" && ![null, void 0].includes(value)) {
        el.value = String(value);
      } else {
        if (Array.isArray(value)) {
          el.checked = value.some((val) => checkedAttrLooseCompare(val, el.value));
        } else {
          el.checked = !!value;
        }
      }
    } else if (el.tagName === "SELECT") {
      updateSelect(el, value);
    } else {
      if (el.value === value)
        return;
      el.value = value === void 0 ? "" : value;
    }
  }
  function bindClasses(el, value) {
    if (el._x_undoAddedClasses)
      el._x_undoAddedClasses();
    el._x_undoAddedClasses = setClasses(el, value);
  }
  function bindStyles(el, value) {
    if (el._x_undoAddedStyles)
      el._x_undoAddedStyles();
    el._x_undoAddedStyles = setStyles(el, value);
  }
  function bindAttributeAndProperty(el, name, value) {
    bindAttribute(el, name, value);
    setPropertyIfChanged(el, name, value);
  }
  function bindAttribute(el, name, value) {
    if ([null, void 0, false].includes(value) && attributeShouldntBePreservedIfFalsy(name)) {
      el.removeAttribute(name);
    } else {
      if (isBooleanAttr(name))
        value = name;
      setIfChanged(el, name, value);
    }
  }
  function setIfChanged(el, attrName, value) {
    if (el.getAttribute(attrName) != value) {
      el.setAttribute(attrName, value);
    }
  }
  function setPropertyIfChanged(el, propName, value) {
    if (el[propName] !== value) {
      el[propName] = value;
    }
  }
  function updateSelect(el, value) {
    const arrayWrappedValue = [].concat(value).map((value2) => {
      return value2 + "";
    });
    Array.from(el.options).forEach((option) => {
      option.selected = arrayWrappedValue.includes(option.value);
    });
  }
  function camelCase(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function checkedAttrLooseCompare(valueA, valueB) {
    return valueA == valueB;
  }
  function safeParseBoolean(rawValue) {
    if ([1, "1", "true", "on", "yes", true].includes(rawValue)) {
      return true;
    }
    if ([0, "0", "false", "off", "no", false].includes(rawValue)) {
      return false;
    }
    return rawValue ? Boolean(rawValue) : null;
  }
  function isBooleanAttr(attrName) {
    const booleanAttributes = [
      "disabled",
      "checked",
      "required",
      "readonly",
      "hidden",
      "open",
      "selected",
      "autofocus",
      "itemscope",
      "multiple",
      "novalidate",
      "allowfullscreen",
      "allowpaymentrequest",
      "formnovalidate",
      "autoplay",
      "controls",
      "loop",
      "muted",
      "playsinline",
      "default",
      "ismap",
      "reversed",
      "async",
      "defer",
      "nomodule"
    ];
    return booleanAttributes.includes(attrName);
  }
  function attributeShouldntBePreservedIfFalsy(name) {
    return !["aria-pressed", "aria-checked", "aria-expanded", "aria-selected"].includes(name);
  }
  function getBinding(el, name, fallback) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    return getAttributeBinding(el, name, fallback);
  }
  function extractProp(el, name, fallback, extract = true) {
    if (el._x_bindings && el._x_bindings[name] !== void 0)
      return el._x_bindings[name];
    if (el._x_inlineBindings && el._x_inlineBindings[name] !== void 0) {
      let binding = el._x_inlineBindings[name];
      binding.extract = extract;
      return dontAutoEvaluateFunctions(() => {
        return evaluate(el, binding.expression);
      });
    }
    return getAttributeBinding(el, name, fallback);
  }
  function getAttributeBinding(el, name, fallback) {
    let attr = el.getAttribute(name);
    if (attr === null)
      return typeof fallback === "function" ? fallback() : fallback;
    if (attr === "")
      return true;
    if (isBooleanAttr(name)) {
      return !![name, "true"].includes(attr);
    }
    return attr;
  }

  // packages/alpinejs/src/utils/debounce.js
  function debounce(func, wait) {
    var timeout;
    return function() {
      var context = this, args = arguments;
      var later = function() {
        timeout = null;
        func.apply(context, args);
      };
      clearTimeout(timeout);
      timeout = setTimeout(later, wait);
    };
  }

  // packages/alpinejs/src/utils/throttle.js
  function throttle(func, limit) {
    let inThrottle;
    return function() {
      let context = this, args = arguments;
      if (!inThrottle) {
        func.apply(context, args);
        inThrottle = true;
        setTimeout(() => inThrottle = false, limit);
      }
    };
  }

  // packages/alpinejs/src/entangle.js
  function entangle({ get: outerGet, set: outerSet }, { get: innerGet, set: innerSet }) {
    let firstRun = true;
    let outerHash;
    let reference = effect(() => {
      let outer = outerGet();
      let inner = innerGet();
      if (firstRun) {
        innerSet(cloneIfObject(outer));
        firstRun = false;
      } else {
        let outerHashLatest = JSON.stringify(outer);
        let innerHashLatest = JSON.stringify(inner);
        if (outerHashLatest !== outerHash) {
          innerSet(cloneIfObject(outer));
        } else if (outerHashLatest !== innerHashLatest) {
          outerSet(cloneIfObject(inner));
        } else ;
      }
      outerHash = JSON.stringify(outerGet());
      JSON.stringify(innerGet());
    });
    return () => {
      release(reference);
    };
  }
  function cloneIfObject(value) {
    return typeof value === "object" ? JSON.parse(JSON.stringify(value)) : value;
  }

  // packages/alpinejs/src/plugin.js
  function plugin(callback) {
    let callbacks = Array.isArray(callback) ? callback : [callback];
    callbacks.forEach((i) => i(alpine_default));
  }

  // packages/alpinejs/src/store.js
  var stores = {};
  var isReactive = false;
  function store(name, value) {
    if (!isReactive) {
      stores = reactive(stores);
      isReactive = true;
    }
    if (value === void 0) {
      return stores[name];
    }
    stores[name] = value;
    if (typeof value === "object" && value !== null && value.hasOwnProperty("init") && typeof value.init === "function") {
      stores[name].init();
    }
    initInterceptors2(stores[name]);
  }
  function getStores() {
    return stores;
  }

  // packages/alpinejs/src/binds.js
  var binds = {};
  function bind2(name, bindings) {
    let getBindings = typeof bindings !== "function" ? () => bindings : bindings;
    if (name instanceof Element) {
      return applyBindingsObject(name, getBindings());
    } else {
      binds[name] = getBindings;
    }
    return () => {
    };
  }
  function injectBindingProviders(obj) {
    Object.entries(binds).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback(...args);
          };
        }
      });
    });
    return obj;
  }
  function applyBindingsObject(el, obj, original) {
    let cleanupRunners = [];
    while (cleanupRunners.length)
      cleanupRunners.pop()();
    let attributes = Object.entries(obj).map(([name, value]) => ({ name, value }));
    let staticAttributes = attributesOnly(attributes);
    attributes = attributes.map((attribute) => {
      if (staticAttributes.find((attr) => attr.name === attribute.name)) {
        return {
          name: `x-bind:${attribute.name}`,
          value: `"${attribute.value}"`
        };
      }
      return attribute;
    });
    directives(el, attributes, original).map((handle) => {
      cleanupRunners.push(handle.runCleanups);
      handle();
    });
    return () => {
      while (cleanupRunners.length)
        cleanupRunners.pop()();
    };
  }

  // packages/alpinejs/src/datas.js
  var datas = {};
  function data(name, callback) {
    datas[name] = callback;
  }
  function injectDataProviders(obj, context) {
    Object.entries(datas).forEach(([name, callback]) => {
      Object.defineProperty(obj, name, {
        get() {
          return (...args) => {
            return callback.bind(context)(...args);
          };
        },
        enumerable: false
      });
    });
    return obj;
  }

  // packages/alpinejs/src/alpine.js
  var Alpine$1 = {
    get reactive() {
      return reactive;
    },
    get release() {
      return release;
    },
    get effect() {
      return effect;
    },
    get raw() {
      return raw;
    },
    version: "3.13.5",
    flushAndStopDeferringMutations,
    dontAutoEvaluateFunctions,
    disableEffectScheduling,
    startObservingMutations,
    stopObservingMutations,
    setReactivityEngine,
    onAttributeRemoved,
    onAttributesAdded,
    closestDataStack,
    skipDuringClone,
    onlyDuringClone,
    addRootSelector,
    addInitSelector,
    interceptClone,
    addScopeToNode,
    deferMutations,
    mapAttributes,
    evaluateLater,
    interceptInit,
    setEvaluator,
    mergeProxies,
    extractProp,
    findClosest,
    onElRemoved,
    closestRoot,
    destroyTree,
    interceptor,
    // INTERNAL: not public API and is subject to change without major release.
    transition,
    // INTERNAL
    setStyles,
    // INTERNAL
    mutateDom,
    directive,
    entangle,
    throttle,
    debounce,
    evaluate,
    initTree,
    nextTick,
    prefixed: prefix,
    prefix: setPrefix,
    plugin,
    magic,
    store,
    start,
    clone,
    // INTERNAL
    cloneNode,
    // INTERNAL
    bound: getBinding,
    $data: scope,
    watch,
    walk,
    data,
    bind: bind2
  };
  var alpine_default = Alpine$1;

  // node_modules/@vue/shared/dist/shared.esm-bundler.js
  function makeMap(str, expectsLowerCase) {
    const map = /* @__PURE__ */ Object.create(null);
    const list = str.split(",");
    for (let i = 0; i < list.length; i++) {
      map[list[i]] = true;
    }
    return expectsLowerCase ? (val) => !!map[val.toLowerCase()] : (val) => !!map[val];
  }
  var EMPTY_OBJ = Object.freeze({}) ;
  var hasOwnProperty = Object.prototype.hasOwnProperty;
  var hasOwn = (val, key) => hasOwnProperty.call(val, key);
  var isArray = Array.isArray;
  var isMap = (val) => toTypeString(val) === "[object Map]";
  var isString = (val) => typeof val === "string";
  var isSymbol = (val) => typeof val === "symbol";
  var isObject = (val) => val !== null && typeof val === "object";
  var objectToString = Object.prototype.toString;
  var toTypeString = (value) => objectToString.call(value);
  var toRawType = (value) => {
    return toTypeString(value).slice(8, -1);
  };
  var isIntegerKey = (key) => isString(key) && key !== "NaN" && key[0] !== "-" && "" + parseInt(key, 10) === key;
  var cacheStringFunction = (fn) => {
    const cache = /* @__PURE__ */ Object.create(null);
    return (str) => {
      const hit = cache[str];
      return hit || (cache[str] = fn(str));
    };
  };
  var capitalize = cacheStringFunction((str) => str.charAt(0).toUpperCase() + str.slice(1));
  var hasChanged = (value, oldValue) => value !== oldValue && (value === value || oldValue === oldValue);

  // node_modules/@vue/reactivity/dist/reactivity.esm-bundler.js
  var targetMap = /* @__PURE__ */ new WeakMap();
  var effectStack = [];
  var activeEffect;
  var ITERATE_KEY = Symbol("iterate" );
  var MAP_KEY_ITERATE_KEY = Symbol("Map key iterate" );
  function isEffect(fn) {
    return fn && fn._isEffect === true;
  }
  function effect2(fn, options = EMPTY_OBJ) {
    if (isEffect(fn)) {
      fn = fn.raw;
    }
    const effect3 = createReactiveEffect(fn, options);
    if (!options.lazy) {
      effect3();
    }
    return effect3;
  }
  function stop(effect3) {
    if (effect3.active) {
      cleanup(effect3);
      if (effect3.options.onStop) {
        effect3.options.onStop();
      }
      effect3.active = false;
    }
  }
  var uid = 0;
  function createReactiveEffect(fn, options) {
    const effect3 = function reactiveEffect() {
      if (!effect3.active) {
        return fn();
      }
      if (!effectStack.includes(effect3)) {
        cleanup(effect3);
        try {
          enableTracking();
          effectStack.push(effect3);
          activeEffect = effect3;
          return fn();
        } finally {
          effectStack.pop();
          resetTracking();
          activeEffect = effectStack[effectStack.length - 1];
        }
      }
    };
    effect3.id = uid++;
    effect3.allowRecurse = !!options.allowRecurse;
    effect3._isEffect = true;
    effect3.active = true;
    effect3.raw = fn;
    effect3.deps = [];
    effect3.options = options;
    return effect3;
  }
  function cleanup(effect3) {
    const { deps } = effect3;
    if (deps.length) {
      for (let i = 0; i < deps.length; i++) {
        deps[i].delete(effect3);
      }
      deps.length = 0;
    }
  }
  var shouldTrack = true;
  var trackStack = [];
  function pauseTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = false;
  }
  function enableTracking() {
    trackStack.push(shouldTrack);
    shouldTrack = true;
  }
  function resetTracking() {
    const last = trackStack.pop();
    shouldTrack = last === void 0 ? true : last;
  }
  function track(target, type, key) {
    if (!shouldTrack || activeEffect === void 0) {
      return;
    }
    let depsMap = targetMap.get(target);
    if (!depsMap) {
      targetMap.set(target, depsMap = /* @__PURE__ */ new Map());
    }
    let dep = depsMap.get(key);
    if (!dep) {
      depsMap.set(key, dep = /* @__PURE__ */ new Set());
    }
    if (!dep.has(activeEffect)) {
      dep.add(activeEffect);
      activeEffect.deps.push(dep);
      if (activeEffect.options.onTrack) {
        activeEffect.options.onTrack({
          effect: activeEffect,
          target,
          type,
          key
        });
      }
    }
  }
  function trigger(target, type, key, newValue, oldValue, oldTarget) {
    const depsMap = targetMap.get(target);
    if (!depsMap) {
      return;
    }
    const effects = /* @__PURE__ */ new Set();
    const add2 = (effectsToAdd) => {
      if (effectsToAdd) {
        effectsToAdd.forEach((effect3) => {
          if (effect3 !== activeEffect || effect3.allowRecurse) {
            effects.add(effect3);
          }
        });
      }
    };
    if (type === "clear") {
      depsMap.forEach(add2);
    } else if (key === "length" && isArray(target)) {
      depsMap.forEach((dep, key2) => {
        if (key2 === "length" || key2 >= newValue) {
          add2(dep);
        }
      });
    } else {
      if (key !== void 0) {
        add2(depsMap.get(key));
      }
      switch (type) {
        case "add":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          } else if (isIntegerKey(key)) {
            add2(depsMap.get("length"));
          }
          break;
        case "delete":
          if (!isArray(target)) {
            add2(depsMap.get(ITERATE_KEY));
            if (isMap(target)) {
              add2(depsMap.get(MAP_KEY_ITERATE_KEY));
            }
          }
          break;
        case "set":
          if (isMap(target)) {
            add2(depsMap.get(ITERATE_KEY));
          }
          break;
      }
    }
    const run = (effect3) => {
      if (effect3.options.onTrigger) {
        effect3.options.onTrigger({
          effect: effect3,
          target,
          key,
          type,
          newValue,
          oldValue,
          oldTarget
        });
      }
      if (effect3.options.scheduler) {
        effect3.options.scheduler(effect3);
      } else {
        effect3();
      }
    };
    effects.forEach(run);
  }
  var isNonTrackableKeys = /* @__PURE__ */ makeMap(`__proto__,__v_isRef,__isVue`);
  var builtInSymbols = new Set(Object.getOwnPropertyNames(Symbol).map((key) => Symbol[key]).filter(isSymbol));
  var get2 = /* @__PURE__ */ createGetter();
  var readonlyGet = /* @__PURE__ */ createGetter(true);
  var arrayInstrumentations = /* @__PURE__ */ createArrayInstrumentations();
  function createArrayInstrumentations() {
    const instrumentations = {};
    ["includes", "indexOf", "lastIndexOf"].forEach((key) => {
      instrumentations[key] = function(...args) {
        const arr = toRaw(this);
        for (let i = 0, l = this.length; i < l; i++) {
          track(arr, "get", i + "");
        }
        const res = arr[key](...args);
        if (res === -1 || res === false) {
          return arr[key](...args.map(toRaw));
        } else {
          return res;
        }
      };
    });
    ["push", "pop", "shift", "unshift", "splice"].forEach((key) => {
      instrumentations[key] = function(...args) {
        pauseTracking();
        const res = toRaw(this)[key].apply(this, args);
        resetTracking();
        return res;
      };
    });
    return instrumentations;
  }
  function createGetter(isReadonly = false, shallow = false) {
    return function get3(target, key, receiver) {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw" && receiver === (isReadonly ? shallow ? shallowReadonlyMap : readonlyMap : shallow ? shallowReactiveMap : reactiveMap).get(target)) {
        return target;
      }
      const targetIsArray = isArray(target);
      if (!isReadonly && targetIsArray && hasOwn(arrayInstrumentations, key)) {
        return Reflect.get(arrayInstrumentations, key, receiver);
      }
      const res = Reflect.get(target, key, receiver);
      if (isSymbol(key) ? builtInSymbols.has(key) : isNonTrackableKeys(key)) {
        return res;
      }
      if (!isReadonly) {
        track(target, "get", key);
      }
      if (shallow) {
        return res;
      }
      if (isRef(res)) {
        const shouldUnwrap = !targetIsArray || !isIntegerKey(key);
        return shouldUnwrap ? res.value : res;
      }
      if (isObject(res)) {
        return isReadonly ? readonly(res) : reactive2(res);
      }
      return res;
    };
  }
  var set2 = /* @__PURE__ */ createSetter();
  function createSetter(shallow = false) {
    return function set3(target, key, value, receiver) {
      let oldValue = target[key];
      if (!shallow) {
        value = toRaw(value);
        oldValue = toRaw(oldValue);
        if (!isArray(target) && isRef(oldValue) && !isRef(value)) {
          oldValue.value = value;
          return true;
        }
      }
      const hadKey = isArray(target) && isIntegerKey(key) ? Number(key) < target.length : hasOwn(target, key);
      const result = Reflect.set(target, key, value, receiver);
      if (target === toRaw(receiver)) {
        if (!hadKey) {
          trigger(target, "add", key, value);
        } else if (hasChanged(value, oldValue)) {
          trigger(target, "set", key, value, oldValue);
        }
      }
      return result;
    };
  }
  function deleteProperty(target, key) {
    const hadKey = hasOwn(target, key);
    const oldValue = target[key];
    const result = Reflect.deleteProperty(target, key);
    if (result && hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function has(target, key) {
    const result = Reflect.has(target, key);
    if (!isSymbol(key) || !builtInSymbols.has(key)) {
      track(target, "has", key);
    }
    return result;
  }
  function ownKeys(target) {
    track(target, "iterate", isArray(target) ? "length" : ITERATE_KEY);
    return Reflect.ownKeys(target);
  }
  var mutableHandlers = {
    get: get2,
    set: set2,
    deleteProperty,
    has,
    ownKeys
  };
  var readonlyHandlers = {
    get: readonlyGet,
    set(target, key) {
      {
        console.warn(`Set operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    },
    deleteProperty(target, key) {
      {
        console.warn(`Delete operation on key "${String(key)}" failed: target is readonly.`, target);
      }
      return true;
    }
  };
  var toReactive = (value) => isObject(value) ? reactive2(value) : value;
  var toReadonly = (value) => isObject(value) ? readonly(value) : value;
  var toShallow = (value) => value;
  var getProto = (v) => Reflect.getPrototypeOf(v);
  function get$1(target, key, isReadonly = false, isShallow = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "get", key);
    }
    !isReadonly && track(rawTarget, "get", rawKey);
    const { has: has2 } = getProto(rawTarget);
    const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
    if (has2.call(rawTarget, key)) {
      return wrap(target.get(key));
    } else if (has2.call(rawTarget, rawKey)) {
      return wrap(target.get(rawKey));
    } else if (target !== rawTarget) {
      target.get(key);
    }
  }
  function has$1(key, isReadonly = false) {
    const target = this[
      "__v_raw"
      /* RAW */
    ];
    const rawTarget = toRaw(target);
    const rawKey = toRaw(key);
    if (key !== rawKey) {
      !isReadonly && track(rawTarget, "has", key);
    }
    !isReadonly && track(rawTarget, "has", rawKey);
    return key === rawKey ? target.has(key) : target.has(key) || target.has(rawKey);
  }
  function size(target, isReadonly = false) {
    target = target[
      "__v_raw"
      /* RAW */
    ];
    !isReadonly && track(toRaw(target), "iterate", ITERATE_KEY);
    return Reflect.get(target, "size", target);
  }
  function add(value) {
    value = toRaw(value);
    const target = toRaw(this);
    const proto = getProto(target);
    const hadKey = proto.has.call(target, value);
    if (!hadKey) {
      target.add(value);
      trigger(target, "add", value, value);
    }
    return this;
  }
  function set$1(key, value) {
    value = toRaw(value);
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3.call(target, key);
    target.set(key, value);
    if (!hadKey) {
      trigger(target, "add", key, value);
    } else if (hasChanged(value, oldValue)) {
      trigger(target, "set", key, value, oldValue);
    }
    return this;
  }
  function deleteEntry(key) {
    const target = toRaw(this);
    const { has: has2, get: get3 } = getProto(target);
    let hadKey = has2.call(target, key);
    if (!hadKey) {
      key = toRaw(key);
      hadKey = has2.call(target, key);
    } else {
      checkIdentityKeys(target, has2, key);
    }
    const oldValue = get3 ? get3.call(target, key) : void 0;
    const result = target.delete(key);
    if (hadKey) {
      trigger(target, "delete", key, void 0, oldValue);
    }
    return result;
  }
  function clear() {
    const target = toRaw(this);
    const hadItems = target.size !== 0;
    const oldTarget = isMap(target) ? new Map(target) : new Set(target) ;
    const result = target.clear();
    if (hadItems) {
      trigger(target, "clear", void 0, void 0, oldTarget);
    }
    return result;
  }
  function createForEach(isReadonly, isShallow) {
    return function forEach(callback, thisArg) {
      const observed = this;
      const target = observed[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", ITERATE_KEY);
      return target.forEach((value, key) => {
        return callback.call(thisArg, wrap(value), wrap(key), observed);
      });
    };
  }
  function createIterableMethod(method, isReadonly, isShallow) {
    return function(...args) {
      const target = this[
        "__v_raw"
        /* RAW */
      ];
      const rawTarget = toRaw(target);
      const targetIsMap = isMap(rawTarget);
      const isPair = method === "entries" || method === Symbol.iterator && targetIsMap;
      const isKeyOnly = method === "keys" && targetIsMap;
      const innerIterator = target[method](...args);
      const wrap = isShallow ? toShallow : isReadonly ? toReadonly : toReactive;
      !isReadonly && track(rawTarget, "iterate", isKeyOnly ? MAP_KEY_ITERATE_KEY : ITERATE_KEY);
      return {
        // iterator protocol
        next() {
          const { value, done } = innerIterator.next();
          return done ? { value, done } : {
            value: isPair ? [wrap(value[0]), wrap(value[1])] : wrap(value),
            done
          };
        },
        // iterable protocol
        [Symbol.iterator]() {
          return this;
        }
      };
    };
  }
  function createReadonlyMethod(type) {
    return function(...args) {
      {
        const key = args[0] ? `on key "${args[0]}" ` : ``;
        console.warn(`${capitalize(type)} operation ${key}failed: target is readonly.`, toRaw(this));
      }
      return type === "delete" ? false : this;
    };
  }
  function createInstrumentations() {
    const mutableInstrumentations2 = {
      get(key) {
        return get$1(this, key);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, false)
    };
    const shallowInstrumentations2 = {
      get(key) {
        return get$1(this, key, false, true);
      },
      get size() {
        return size(this);
      },
      has: has$1,
      add,
      set: set$1,
      delete: deleteEntry,
      clear,
      forEach: createForEach(false, true)
    };
    const readonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, false)
    };
    const shallowReadonlyInstrumentations2 = {
      get(key) {
        return get$1(this, key, true, true);
      },
      get size() {
        return size(this, true);
      },
      has(key) {
        return has$1.call(this, key, true);
      },
      add: createReadonlyMethod(
        "add"
        /* ADD */
      ),
      set: createReadonlyMethod(
        "set"
        /* SET */
      ),
      delete: createReadonlyMethod(
        "delete"
        /* DELETE */
      ),
      clear: createReadonlyMethod(
        "clear"
        /* CLEAR */
      ),
      forEach: createForEach(true, true)
    };
    const iteratorMethods = ["keys", "values", "entries", Symbol.iterator];
    iteratorMethods.forEach((method) => {
      mutableInstrumentations2[method] = createIterableMethod(method, false, false);
      readonlyInstrumentations2[method] = createIterableMethod(method, true, false);
      shallowInstrumentations2[method] = createIterableMethod(method, false, true);
      shallowReadonlyInstrumentations2[method] = createIterableMethod(method, true, true);
    });
    return [
      mutableInstrumentations2,
      readonlyInstrumentations2,
      shallowInstrumentations2,
      shallowReadonlyInstrumentations2
    ];
  }
  var [mutableInstrumentations, readonlyInstrumentations, shallowInstrumentations, shallowReadonlyInstrumentations] = /* @__PURE__ */ createInstrumentations();
  function createInstrumentationGetter(isReadonly, shallow) {
    const instrumentations = shallow ? isReadonly ? shallowReadonlyInstrumentations : shallowInstrumentations : isReadonly ? readonlyInstrumentations : mutableInstrumentations;
    return (target, key, receiver) => {
      if (key === "__v_isReactive") {
        return !isReadonly;
      } else if (key === "__v_isReadonly") {
        return isReadonly;
      } else if (key === "__v_raw") {
        return target;
      }
      return Reflect.get(hasOwn(instrumentations, key) && key in target ? instrumentations : target, key, receiver);
    };
  }
  var mutableCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(false, false)
  };
  var readonlyCollectionHandlers = {
    get: /* @__PURE__ */ createInstrumentationGetter(true, false)
  };
  function checkIdentityKeys(target, has2, key) {
    const rawKey = toRaw(key);
    if (rawKey !== key && has2.call(target, rawKey)) {
      const type = toRawType(target);
      console.warn(`Reactive ${type} contains both the raw and reactive versions of the same object${type === `Map` ? ` as keys` : ``}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`);
    }
  }
  var reactiveMap = /* @__PURE__ */ new WeakMap();
  var shallowReactiveMap = /* @__PURE__ */ new WeakMap();
  var readonlyMap = /* @__PURE__ */ new WeakMap();
  var shallowReadonlyMap = /* @__PURE__ */ new WeakMap();
  function targetTypeMap(rawType) {
    switch (rawType) {
      case "Object":
      case "Array":
        return 1;
      case "Map":
      case "Set":
      case "WeakMap":
      case "WeakSet":
        return 2;
      default:
        return 0;
    }
  }
  function getTargetType(value) {
    return value[
      "__v_skip"
      /* SKIP */
    ] || !Object.isExtensible(value) ? 0 : targetTypeMap(toRawType(value));
  }
  function reactive2(target) {
    if (target && target[
      "__v_isReadonly"
      /* IS_READONLY */
    ]) {
      return target;
    }
    return createReactiveObject(target, false, mutableHandlers, mutableCollectionHandlers, reactiveMap);
  }
  function readonly(target) {
    return createReactiveObject(target, true, readonlyHandlers, readonlyCollectionHandlers, readonlyMap);
  }
  function createReactiveObject(target, isReadonly, baseHandlers, collectionHandlers, proxyMap) {
    if (!isObject(target)) {
      {
        console.warn(`value cannot be made reactive: ${String(target)}`);
      }
      return target;
    }
    if (target[
      "__v_raw"
      /* RAW */
    ] && !(isReadonly && target[
      "__v_isReactive"
      /* IS_REACTIVE */
    ])) {
      return target;
    }
    const existingProxy = proxyMap.get(target);
    if (existingProxy) {
      return existingProxy;
    }
    const targetType = getTargetType(target);
    if (targetType === 0) {
      return target;
    }
    const proxy = new Proxy(target, targetType === 2 ? collectionHandlers : baseHandlers);
    proxyMap.set(target, proxy);
    return proxy;
  }
  function toRaw(observed) {
    return observed && toRaw(observed[
      "__v_raw"
      /* RAW */
    ]) || observed;
  }
  function isRef(r) {
    return Boolean(r && r.__v_isRef === true);
  }

  // packages/alpinejs/src/magics/$nextTick.js
  magic("nextTick", () => nextTick);

  // packages/alpinejs/src/magics/$dispatch.js
  magic("dispatch", (el) => dispatch.bind(dispatch, el));

  // packages/alpinejs/src/magics/$watch.js
  magic("watch", (el, { evaluateLater: evaluateLater2, cleanup: cleanup2 }) => (key, callback) => {
    let evaluate2 = evaluateLater2(key);
    let getter = () => {
      let value;
      evaluate2((i) => value = i);
      return value;
    };
    let unwatch = watch(getter, callback);
    cleanup2(unwatch);
  });

  // packages/alpinejs/src/magics/$store.js
  magic("store", getStores);

  // packages/alpinejs/src/magics/$data.js
  magic("data", (el) => scope(el));

  // packages/alpinejs/src/magics/$root.js
  magic("root", (el) => closestRoot(el));

  // packages/alpinejs/src/magics/$refs.js
  magic("refs", (el) => {
    if (el._x_refs_proxy)
      return el._x_refs_proxy;
    el._x_refs_proxy = mergeProxies(getArrayOfRefObject(el));
    return el._x_refs_proxy;
  });
  function getArrayOfRefObject(el) {
    let refObjects = [];
    let currentEl = el;
    while (currentEl) {
      if (currentEl._x_refs)
        refObjects.push(currentEl._x_refs);
      currentEl = currentEl.parentNode;
    }
    return refObjects;
  }

  // packages/alpinejs/src/ids.js
  var globalIdMemo = {};
  function findAndIncrementId(name) {
    if (!globalIdMemo[name])
      globalIdMemo[name] = 0;
    return ++globalIdMemo[name];
  }
  function closestIdRoot(el, name) {
    return findClosest(el, (element) => {
      if (element._x_ids && element._x_ids[name])
        return true;
    });
  }
  function setIdRoot(el, name) {
    if (!el._x_ids)
      el._x_ids = {};
    if (!el._x_ids[name])
      el._x_ids[name] = findAndIncrementId(name);
  }

  // packages/alpinejs/src/magics/$id.js
  magic("id", (el, { cleanup: cleanup2 }) => (name, key = null) => {
    let cacheKey = `${name}${key ? `-${key}` : ""}`;
    return cacheIdByNameOnElement(el, cacheKey, cleanup2, () => {
      let root = closestIdRoot(el, name);
      let id = root ? root._x_ids[name] : findAndIncrementId(name);
      return key ? `${name}-${id}-${key}` : `${name}-${id}`;
    });
  });
  interceptClone((from, to) => {
    if (from._x_id) {
      to._x_id = from._x_id;
    }
  });
  function cacheIdByNameOnElement(el, cacheKey, cleanup2, callback) {
    if (!el._x_id)
      el._x_id = {};
    if (el._x_id[cacheKey])
      return el._x_id[cacheKey];
    let output = callback();
    el._x_id[cacheKey] = output;
    cleanup2(() => {
      delete el._x_id[cacheKey];
    });
    return output;
  }

  // packages/alpinejs/src/magics/$el.js
  magic("el", (el) => el);

  // packages/alpinejs/src/magics/index.js
  warnMissingPluginMagic("Focus", "focus", "focus");
  warnMissingPluginMagic("Persist", "persist", "persist");
  function warnMissingPluginMagic(name, magicName, slug) {
    magic(magicName, (el) => warn(`You can't use [$${magicName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }

  // packages/alpinejs/src/directives/x-modelable.js
  directive("modelable", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2, cleanup: cleanup2 }) => {
    let func = evaluateLater2(expression);
    let innerGet = () => {
      let result;
      func((i) => result = i);
      return result;
    };
    let evaluateInnerSet = evaluateLater2(`${expression} = __placeholder`);
    let innerSet = (val) => evaluateInnerSet(() => {
    }, { scope: { "__placeholder": val } });
    let initialValue = innerGet();
    innerSet(initialValue);
    queueMicrotask(() => {
      if (!el._x_model)
        return;
      el._x_removeModelListeners["default"]();
      let outerGet = el._x_model.get;
      let outerSet = el._x_model.set;
      let releaseEntanglement = entangle(
        {
          get() {
            return outerGet();
          },
          set(value) {
            outerSet(value);
          }
        },
        {
          get() {
            return innerGet();
          },
          set(value) {
            innerSet(value);
          }
        }
      );
      cleanup2(releaseEntanglement);
    });
  });

  // packages/alpinejs/src/directives/x-teleport.js
  directive("teleport", (el, { modifiers, expression }, { cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-teleport can only be used on a <template> tag", el);
    let target = getTarget(expression);
    let clone2 = el.content.cloneNode(true).firstElementChild;
    el._x_teleport = clone2;
    clone2._x_teleportBack = el;
    el.setAttribute("data-teleport-template", true);
    clone2.setAttribute("data-teleport-target", true);
    if (el._x_forwardEvents) {
      el._x_forwardEvents.forEach((eventName) => {
        clone2.addEventListener(eventName, (e) => {
          e.stopPropagation();
          el.dispatchEvent(new e.constructor(e.type, e));
        });
      });
    }
    addScopeToNode(clone2, {}, el);
    let placeInDom = (clone3, target2, modifiers2) => {
      if (modifiers2.includes("prepend")) {
        target2.parentNode.insertBefore(clone3, target2);
      } else if (modifiers2.includes("append")) {
        target2.parentNode.insertBefore(clone3, target2.nextSibling);
      } else {
        target2.appendChild(clone3);
      }
    };
    mutateDom(() => {
      placeInDom(clone2, target, modifiers);
      initTree(clone2);
      clone2._x_ignore = true;
    });
    el._x_teleportPutBack = () => {
      let target2 = getTarget(expression);
      mutateDom(() => {
        placeInDom(el._x_teleport, target2, modifiers);
      });
    };
    cleanup2(() => clone2.remove());
  });
  var teleportContainerDuringClone = document.createElement("div");
  function getTarget(expression) {
    let target = skipDuringClone(() => {
      return document.querySelector(expression);
    }, () => {
      return teleportContainerDuringClone;
    })();
    if (!target)
      warn(`Cannot find x-teleport element for selector: "${expression}"`);
    return target;
  }

  // packages/alpinejs/src/directives/x-ignore.js
  var handler = () => {
  };
  handler.inline = (el, { modifiers }, { cleanup: cleanup2 }) => {
    modifiers.includes("self") ? el._x_ignoreSelf = true : el._x_ignore = true;
    cleanup2(() => {
      modifiers.includes("self") ? delete el._x_ignoreSelf : delete el._x_ignore;
    });
  };
  directive("ignore", handler);

  // packages/alpinejs/src/directives/x-effect.js
  directive("effect", skipDuringClone((el, { expression }, { effect: effect3 }) => {
    effect3(evaluateLater(el, expression));
  }));

  // packages/alpinejs/src/utils/on.js
  function on(el, event, modifiers, callback) {
    let listenerTarget = el;
    let handler4 = (e) => callback(e);
    let options = {};
    let wrapHandler = (callback2, wrapper) => (e) => wrapper(callback2, e);
    if (modifiers.includes("dot"))
      event = dotSyntax(event);
    if (modifiers.includes("camel"))
      event = camelCase2(event);
    if (modifiers.includes("passive"))
      options.passive = true;
    if (modifiers.includes("capture"))
      options.capture = true;
    if (modifiers.includes("window"))
      listenerTarget = window;
    if (modifiers.includes("document"))
      listenerTarget = document;
    if (modifiers.includes("debounce")) {
      let nextModifier = modifiers[modifiers.indexOf("debounce") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = debounce(handler4, wait);
    }
    if (modifiers.includes("throttle")) {
      let nextModifier = modifiers[modifiers.indexOf("throttle") + 1] || "invalid-wait";
      let wait = isNumeric(nextModifier.split("ms")[0]) ? Number(nextModifier.split("ms")[0]) : 250;
      handler4 = throttle(handler4, wait);
    }
    if (modifiers.includes("prevent"))
      handler4 = wrapHandler(handler4, (next, e) => {
        e.preventDefault();
        next(e);
      });
    if (modifiers.includes("stop"))
      handler4 = wrapHandler(handler4, (next, e) => {
        e.stopPropagation();
        next(e);
      });
    if (modifiers.includes("self"))
      handler4 = wrapHandler(handler4, (next, e) => {
        e.target === el && next(e);
      });
    if (modifiers.includes("away") || modifiers.includes("outside")) {
      listenerTarget = document;
      handler4 = wrapHandler(handler4, (next, e) => {
        if (el.contains(e.target))
          return;
        if (e.target.isConnected === false)
          return;
        if (el.offsetWidth < 1 && el.offsetHeight < 1)
          return;
        if (el._x_isShown === false)
          return;
        next(e);
      });
    }
    if (modifiers.includes("once")) {
      handler4 = wrapHandler(handler4, (next, e) => {
        next(e);
        listenerTarget.removeEventListener(event, handler4, options);
      });
    }
    handler4 = wrapHandler(handler4, (next, e) => {
      if (isKeyEvent(event)) {
        if (isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers)) {
          return;
        }
      }
      next(e);
    });
    listenerTarget.addEventListener(event, handler4, options);
    return () => {
      listenerTarget.removeEventListener(event, handler4, options);
    };
  }
  function dotSyntax(subject) {
    return subject.replace(/-/g, ".");
  }
  function camelCase2(subject) {
    return subject.toLowerCase().replace(/-(\w)/g, (match, char) => char.toUpperCase());
  }
  function isNumeric(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function kebabCase2(subject) {
    if ([" ", "_"].includes(
      subject
    ))
      return subject;
    return subject.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[_\s]/, "-").toLowerCase();
  }
  function isKeyEvent(event) {
    return ["keydown", "keyup"].includes(event);
  }
  function isListeningForASpecificKeyThatHasntBeenPressed(e, modifiers) {
    let keyModifiers = modifiers.filter((i) => {
      return !["window", "document", "prevent", "stop", "once", "capture"].includes(i);
    });
    if (keyModifiers.includes("debounce")) {
      let debounceIndex = keyModifiers.indexOf("debounce");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.includes("throttle")) {
      let debounceIndex = keyModifiers.indexOf("throttle");
      keyModifiers.splice(debounceIndex, isNumeric((keyModifiers[debounceIndex + 1] || "invalid-wait").split("ms")[0]) ? 2 : 1);
    }
    if (keyModifiers.length === 0)
      return false;
    if (keyModifiers.length === 1 && keyToModifiers(e.key).includes(keyModifiers[0]))
      return false;
    const systemKeyModifiers = ["ctrl", "shift", "alt", "meta", "cmd", "super"];
    const selectedSystemKeyModifiers = systemKeyModifiers.filter((modifier) => keyModifiers.includes(modifier));
    keyModifiers = keyModifiers.filter((i) => !selectedSystemKeyModifiers.includes(i));
    if (selectedSystemKeyModifiers.length > 0) {
      const activelyPressedKeyModifiers = selectedSystemKeyModifiers.filter((modifier) => {
        if (modifier === "cmd" || modifier === "super")
          modifier = "meta";
        return e[`${modifier}Key`];
      });
      if (activelyPressedKeyModifiers.length === selectedSystemKeyModifiers.length) {
        if (keyToModifiers(e.key).includes(keyModifiers[0]))
          return false;
      }
    }
    return true;
  }
  function keyToModifiers(key) {
    if (!key)
      return [];
    key = kebabCase2(key);
    let modifierToKeyMap = {
      "ctrl": "control",
      "slash": "/",
      "space": " ",
      "spacebar": " ",
      "cmd": "meta",
      "esc": "escape",
      "up": "arrow-up",
      "down": "arrow-down",
      "left": "arrow-left",
      "right": "arrow-right",
      "period": ".",
      "equal": "=",
      "minus": "-",
      "underscore": "_"
    };
    modifierToKeyMap[key] = key;
    return Object.keys(modifierToKeyMap).map((modifier) => {
      if (modifierToKeyMap[modifier] === key)
        return modifier;
    }).filter((modifier) => modifier);
  }

  // packages/alpinejs/src/directives/x-model.js
  directive("model", (el, { modifiers, expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let scopeTarget = el;
    if (modifiers.includes("parent")) {
      scopeTarget = el.parentNode;
    }
    let evaluateGet = evaluateLater(scopeTarget, expression);
    let evaluateSet;
    if (typeof expression === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression} = __placeholder`);
    } else if (typeof expression === "function" && typeof expression() === "string") {
      evaluateSet = evaluateLater(scopeTarget, `${expression()} = __placeholder`);
    } else {
      evaluateSet = () => {
      };
    }
    let getValue = () => {
      let result;
      evaluateGet((value) => result = value);
      return isGetterSetter(result) ? result.get() : result;
    };
    let setValue = (value) => {
      let result;
      evaluateGet((value2) => result = value2);
      if (isGetterSetter(result)) {
        result.set(value);
      } else {
        evaluateSet(() => {
        }, {
          scope: { "__placeholder": value }
        });
      }
    };
    if (typeof expression === "string" && el.type === "radio") {
      mutateDom(() => {
        if (!el.hasAttribute("name"))
          el.setAttribute("name", expression);
      });
    }
    var event = el.tagName.toLowerCase() === "select" || ["checkbox", "radio"].includes(el.type) || modifiers.includes("lazy") ? "change" : "input";
    let removeListener = isCloning ? () => {
    } : on(el, event, modifiers, (e) => {
      setValue(getInputValue(el, modifiers, e, getValue()));
    });
    if (modifiers.includes("fill")) {
      if ([void 0, null, ""].includes(getValue()) || el.type === "checkbox" && Array.isArray(getValue())) {
        el.dispatchEvent(new Event(event, {}));
      }
    }
    if (!el._x_removeModelListeners)
      el._x_removeModelListeners = {};
    el._x_removeModelListeners["default"] = removeListener;
    cleanup2(() => el._x_removeModelListeners["default"]());
    if (el.form) {
      let removeResetListener = on(el.form, "reset", [], (e) => {
        nextTick(() => el._x_model && el._x_model.set(el.value));
      });
      cleanup2(() => removeResetListener());
    }
    el._x_model = {
      get() {
        return getValue();
      },
      set(value) {
        setValue(value);
      }
    };
    el._x_forceModelUpdate = (value) => {
      if (value === void 0 && typeof expression === "string" && expression.match(/\./))
        value = "";
      window.fromModel = true;
      mutateDom(() => bind(el, "value", value));
      delete window.fromModel;
    };
    effect3(() => {
      let value = getValue();
      if (modifiers.includes("unintrusive") && document.activeElement.isSameNode(el))
        return;
      el._x_forceModelUpdate(value);
    });
  });
  function getInputValue(el, modifiers, event, currentValue) {
    return mutateDom(() => {
      if (event instanceof CustomEvent && event.detail !== void 0)
        return event.detail !== null && event.detail !== void 0 ? event.detail : event.target.value;
      else if (el.type === "checkbox") {
        if (Array.isArray(currentValue)) {
          let newValue = null;
          if (modifiers.includes("number")) {
            newValue = safeParseNumber(event.target.value);
          } else if (modifiers.includes("boolean")) {
            newValue = safeParseBoolean(event.target.value);
          } else {
            newValue = event.target.value;
          }
          return event.target.checked ? currentValue.concat([newValue]) : currentValue.filter((el2) => !checkedAttrLooseCompare2(el2, newValue));
        } else {
          return event.target.checked;
        }
      } else if (el.tagName.toLowerCase() === "select" && el.multiple) {
        if (modifiers.includes("number")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseNumber(rawValue);
          });
        } else if (modifiers.includes("boolean")) {
          return Array.from(event.target.selectedOptions).map((option) => {
            let rawValue = option.value || option.text;
            return safeParseBoolean(rawValue);
          });
        }
        return Array.from(event.target.selectedOptions).map((option) => {
          return option.value || option.text;
        });
      } else {
        if (modifiers.includes("number")) {
          return safeParseNumber(event.target.value);
        } else if (modifiers.includes("boolean")) {
          return safeParseBoolean(event.target.value);
        }
        return modifiers.includes("trim") ? event.target.value.trim() : event.target.value;
      }
    });
  }
  function safeParseNumber(rawValue) {
    let number = rawValue ? parseFloat(rawValue) : null;
    return isNumeric2(number) ? number : rawValue;
  }
  function checkedAttrLooseCompare2(valueA, valueB) {
    return valueA == valueB;
  }
  function isNumeric2(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }
  function isGetterSetter(value) {
    return value !== null && typeof value === "object" && typeof value.get === "function" && typeof value.set === "function";
  }

  // packages/alpinejs/src/directives/x-cloak.js
  directive("cloak", (el) => queueMicrotask(() => mutateDom(() => el.removeAttribute(prefix("cloak")))));

  // packages/alpinejs/src/directives/x-init.js
  addInitSelector(() => `[${prefix("init")}]`);
  directive("init", skipDuringClone((el, { expression }, { evaluate: evaluate2 }) => {
    if (typeof expression === "string") {
      return !!expression.trim() && evaluate2(expression, {}, false);
    }
    return evaluate2(expression, {}, false);
  }));

  // packages/alpinejs/src/directives/x-text.js
  directive("text", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.textContent = value;
        });
      });
    });
  });

  // packages/alpinejs/src/directives/x-html.js
  directive("html", (el, { expression }, { effect: effect3, evaluateLater: evaluateLater2 }) => {
    let evaluate2 = evaluateLater2(expression);
    effect3(() => {
      evaluate2((value) => {
        mutateDom(() => {
          el.innerHTML = value;
          el._x_ignoreSelf = true;
          initTree(el);
          delete el._x_ignoreSelf;
        });
      });
    });
  });

  // packages/alpinejs/src/directives/x-bind.js
  mapAttributes(startingWith(":", into(prefix("bind:"))));
  var handler2 = (el, { value, modifiers, expression, original }, { effect: effect3 }) => {
    if (!value) {
      let bindingProviders = {};
      injectBindingProviders(bindingProviders);
      let getBindings = evaluateLater(el, expression);
      getBindings((bindings) => {
        applyBindingsObject(el, bindings, original);
      }, { scope: bindingProviders });
      return;
    }
    if (value === "key")
      return storeKeyForXFor(el, expression);
    if (el._x_inlineBindings && el._x_inlineBindings[value] && el._x_inlineBindings[value].extract) {
      return;
    }
    let evaluate2 = evaluateLater(el, expression);
    effect3(() => evaluate2((result) => {
      if (result === void 0 && typeof expression === "string" && expression.match(/\./)) {
        result = "";
      }
      mutateDom(() => bind(el, value, result, modifiers));
    }));
  };
  handler2.inline = (el, { value, modifiers, expression }) => {
    if (!value)
      return;
    if (!el._x_inlineBindings)
      el._x_inlineBindings = {};
    el._x_inlineBindings[value] = { expression, extract: false };
  };
  directive("bind", handler2);
  function storeKeyForXFor(el, expression) {
    el._x_keyExpression = expression;
  }

  // packages/alpinejs/src/directives/x-data.js
  addRootSelector(() => `[${prefix("data")}]`);
  directive("data", (el, { expression }, { cleanup: cleanup2 }) => {
    if (shouldSkipRegisteringDataDuringClone(el))
      return;
    expression = expression === "" ? "{}" : expression;
    let magicContext = {};
    injectMagics(magicContext, el);
    let dataProviderContext = {};
    injectDataProviders(dataProviderContext, magicContext);
    let data2 = evaluate(el, expression, { scope: dataProviderContext });
    if (data2 === void 0 || data2 === true)
      data2 = {};
    injectMagics(data2, el);
    let reactiveData = reactive(data2);
    initInterceptors2(reactiveData);
    let undo = addScopeToNode(el, reactiveData);
    reactiveData["init"] && evaluate(el, reactiveData["init"]);
    cleanup2(() => {
      reactiveData["destroy"] && evaluate(el, reactiveData["destroy"]);
      undo();
    });
  });
  interceptClone((from, to) => {
    if (from._x_dataStack) {
      to._x_dataStack = from._x_dataStack;
      to.setAttribute("data-has-alpine-state", true);
    }
  });
  function shouldSkipRegisteringDataDuringClone(el) {
    if (!isCloning)
      return false;
    if (isCloningLegacy)
      return true;
    return el.hasAttribute("data-has-alpine-state");
  }

  // packages/alpinejs/src/directives/x-show.js
  directive("show", (el, { modifiers, expression }, { effect: effect3 }) => {
    let evaluate2 = evaluateLater(el, expression);
    if (!el._x_doHide)
      el._x_doHide = () => {
        mutateDom(() => {
          el.style.setProperty("display", "none", modifiers.includes("important") ? "important" : void 0);
        });
      };
    if (!el._x_doShow)
      el._x_doShow = () => {
        mutateDom(() => {
          if (el.style.length === 1 && el.style.display === "none") {
            el.removeAttribute("style");
          } else {
            el.style.removeProperty("display");
          }
        });
      };
    let hide = () => {
      el._x_doHide();
      el._x_isShown = false;
    };
    let show = () => {
      el._x_doShow();
      el._x_isShown = true;
    };
    let clickAwayCompatibleShow = () => setTimeout(show);
    let toggle = once(
      (value) => value ? show() : hide(),
      (value) => {
        if (typeof el._x_toggleAndCascadeWithTransitions === "function") {
          el._x_toggleAndCascadeWithTransitions(el, value, show, hide);
        } else {
          value ? clickAwayCompatibleShow() : hide();
        }
      }
    );
    let oldValue;
    let firstTime = true;
    effect3(() => evaluate2((value) => {
      if (!firstTime && value === oldValue)
        return;
      if (modifiers.includes("immediate"))
        value ? clickAwayCompatibleShow() : hide();
      toggle(value);
      oldValue = value;
      firstTime = false;
    }));
  });

  // packages/alpinejs/src/directives/x-for.js
  directive("for", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    let iteratorNames = parseForExpression(expression);
    let evaluateItems = evaluateLater(el, iteratorNames.items);
    let evaluateKey = evaluateLater(
      el,
      // the x-bind:key expression is stored for our use instead of evaluated.
      el._x_keyExpression || "index"
    );
    el._x_prevKeys = [];
    el._x_lookup = {};
    effect3(() => loop(el, iteratorNames, evaluateItems, evaluateKey));
    cleanup2(() => {
      Object.values(el._x_lookup).forEach((el2) => el2.remove());
      delete el._x_prevKeys;
      delete el._x_lookup;
    });
  });
  function loop(el, iteratorNames, evaluateItems, evaluateKey) {
    let isObject2 = (i) => typeof i === "object" && !Array.isArray(i);
    let templateEl = el;
    evaluateItems((items) => {
      if (isNumeric3(items) && items >= 0) {
        items = Array.from(Array(items).keys(), (i) => i + 1);
      }
      if (items === void 0)
        items = [];
      let lookup = el._x_lookup;
      let prevKeys = el._x_prevKeys;
      let scopes = [];
      let keys = [];
      if (isObject2(items)) {
        items = Object.entries(items).map(([key, value]) => {
          let scope2 = getIterationScopeVariables(iteratorNames, value, key, items);
          evaluateKey((value2) => keys.push(value2), { scope: { index: key, ...scope2 } });
          scopes.push(scope2);
        });
      } else {
        for (let i = 0; i < items.length; i++) {
          let scope2 = getIterationScopeVariables(iteratorNames, items[i], i, items);
          evaluateKey((value) => keys.push(value), { scope: { index: i, ...scope2 } });
          scopes.push(scope2);
        }
      }
      let adds = [];
      let moves = [];
      let removes = [];
      let sames = [];
      for (let i = 0; i < prevKeys.length; i++) {
        let key = prevKeys[i];
        if (keys.indexOf(key) === -1)
          removes.push(key);
      }
      prevKeys = prevKeys.filter((key) => !removes.includes(key));
      let lastKey = "template";
      for (let i = 0; i < keys.length; i++) {
        let key = keys[i];
        let prevIndex = prevKeys.indexOf(key);
        if (prevIndex === -1) {
          prevKeys.splice(i, 0, key);
          adds.push([lastKey, i]);
        } else if (prevIndex !== i) {
          let keyInSpot = prevKeys.splice(i, 1)[0];
          let keyForSpot = prevKeys.splice(prevIndex - 1, 1)[0];
          prevKeys.splice(i, 0, keyForSpot);
          prevKeys.splice(prevIndex, 0, keyInSpot);
          moves.push([keyInSpot, keyForSpot]);
        } else {
          sames.push(key);
        }
        lastKey = key;
      }
      for (let i = 0; i < removes.length; i++) {
        let key = removes[i];
        if (!!lookup[key]._x_effects) {
          lookup[key]._x_effects.forEach(dequeueJob);
        }
        lookup[key].remove();
        lookup[key] = null;
        delete lookup[key];
      }
      for (let i = 0; i < moves.length; i++) {
        let [keyInSpot, keyForSpot] = moves[i];
        let elInSpot = lookup[keyInSpot];
        let elForSpot = lookup[keyForSpot];
        let marker = document.createElement("div");
        mutateDom(() => {
          if (!elForSpot)
            warn(`x-for ":key" is undefined or invalid`, templateEl);
          elForSpot.after(marker);
          elInSpot.after(elForSpot);
          elForSpot._x_currentIfEl && elForSpot.after(elForSpot._x_currentIfEl);
          marker.before(elInSpot);
          elInSpot._x_currentIfEl && elInSpot.after(elInSpot._x_currentIfEl);
          marker.remove();
        });
        elForSpot._x_refreshXForScope(scopes[keys.indexOf(keyForSpot)]);
      }
      for (let i = 0; i < adds.length; i++) {
        let [lastKey2, index] = adds[i];
        let lastEl = lastKey2 === "template" ? templateEl : lookup[lastKey2];
        if (lastEl._x_currentIfEl)
          lastEl = lastEl._x_currentIfEl;
        let scope2 = scopes[index];
        let key = keys[index];
        let clone2 = document.importNode(templateEl.content, true).firstElementChild;
        let reactiveScope = reactive(scope2);
        addScopeToNode(clone2, reactiveScope, templateEl);
        clone2._x_refreshXForScope = (newScope) => {
          Object.entries(newScope).forEach(([key2, value]) => {
            reactiveScope[key2] = value;
          });
        };
        mutateDom(() => {
          lastEl.after(clone2);
          initTree(clone2);
        });
        if (typeof key === "object") {
          warn("x-for key cannot be an object, it must be a string or an integer", templateEl);
        }
        lookup[key] = clone2;
      }
      for (let i = 0; i < sames.length; i++) {
        lookup[sames[i]]._x_refreshXForScope(scopes[keys.indexOf(sames[i])]);
      }
      templateEl._x_prevKeys = keys;
    });
  }
  function parseForExpression(expression) {
    let forIteratorRE = /,([^,\}\]]*)(?:,([^,\}\]]*))?$/;
    let stripParensRE = /^\s*\(|\)\s*$/g;
    let forAliasRE = /([\s\S]*?)\s+(?:in|of)\s+([\s\S]*)/;
    let inMatch = expression.match(forAliasRE);
    if (!inMatch)
      return;
    let res = {};
    res.items = inMatch[2].trim();
    let item = inMatch[1].replace(stripParensRE, "").trim();
    let iteratorMatch = item.match(forIteratorRE);
    if (iteratorMatch) {
      res.item = item.replace(forIteratorRE, "").trim();
      res.index = iteratorMatch[1].trim();
      if (iteratorMatch[2]) {
        res.collection = iteratorMatch[2].trim();
      }
    } else {
      res.item = item;
    }
    return res;
  }
  function getIterationScopeVariables(iteratorNames, item, index, items) {
    let scopeVariables = {};
    if (/^\[.*\]$/.test(iteratorNames.item) && Array.isArray(item)) {
      let names = iteratorNames.item.replace("[", "").replace("]", "").split(",").map((i) => i.trim());
      names.forEach((name, i) => {
        scopeVariables[name] = item[i];
      });
    } else if (/^\{.*\}$/.test(iteratorNames.item) && !Array.isArray(item) && typeof item === "object") {
      let names = iteratorNames.item.replace("{", "").replace("}", "").split(",").map((i) => i.trim());
      names.forEach((name) => {
        scopeVariables[name] = item[name];
      });
    } else {
      scopeVariables[iteratorNames.item] = item;
    }
    if (iteratorNames.index)
      scopeVariables[iteratorNames.index] = index;
    if (iteratorNames.collection)
      scopeVariables[iteratorNames.collection] = items;
    return scopeVariables;
  }
  function isNumeric3(subject) {
    return !Array.isArray(subject) && !isNaN(subject);
  }

  // packages/alpinejs/src/directives/x-ref.js
  function handler3() {
  }
  handler3.inline = (el, { expression }, { cleanup: cleanup2 }) => {
    let root = closestRoot(el);
    if (!root._x_refs)
      root._x_refs = {};
    root._x_refs[expression] = el;
    cleanup2(() => delete root._x_refs[expression]);
  };
  directive("ref", handler3);

  // packages/alpinejs/src/directives/x-if.js
  directive("if", (el, { expression }, { effect: effect3, cleanup: cleanup2 }) => {
    if (el.tagName.toLowerCase() !== "template")
      warn("x-if can only be used on a <template> tag", el);
    let evaluate2 = evaluateLater(el, expression);
    let show = () => {
      if (el._x_currentIfEl)
        return el._x_currentIfEl;
      let clone2 = el.content.cloneNode(true).firstElementChild;
      addScopeToNode(clone2, {}, el);
      mutateDom(() => {
        el.after(clone2);
        initTree(clone2);
      });
      el._x_currentIfEl = clone2;
      el._x_undoIf = () => {
        walk(clone2, (node) => {
          if (!!node._x_effects) {
            node._x_effects.forEach(dequeueJob);
          }
        });
        clone2.remove();
        delete el._x_currentIfEl;
      };
      return clone2;
    };
    let hide = () => {
      if (!el._x_undoIf)
        return;
      el._x_undoIf();
      delete el._x_undoIf;
    };
    effect3(() => evaluate2((value) => {
      value ? show() : hide();
    }));
    cleanup2(() => el._x_undoIf && el._x_undoIf());
  });

  // packages/alpinejs/src/directives/x-id.js
  directive("id", (el, { expression }, { evaluate: evaluate2 }) => {
    let names = evaluate2(expression);
    names.forEach((name) => setIdRoot(el, name));
  });
  interceptClone((from, to) => {
    if (from._x_ids) {
      to._x_ids = from._x_ids;
    }
  });

  // packages/alpinejs/src/directives/x-on.js
  mapAttributes(startingWith("@", into(prefix("on:"))));
  directive("on", skipDuringClone((el, { value, modifiers, expression }, { cleanup: cleanup2 }) => {
    let evaluate2 = expression ? evaluateLater(el, expression) : () => {
    };
    if (el.tagName.toLowerCase() === "template") {
      if (!el._x_forwardEvents)
        el._x_forwardEvents = [];
      if (!el._x_forwardEvents.includes(value))
        el._x_forwardEvents.push(value);
    }
    let removeListener = on(el, value, modifiers, (e) => {
      evaluate2(() => {
      }, { scope: { "$event": e }, params: [e] });
    });
    cleanup2(() => removeListener());
  }));

  // packages/alpinejs/src/directives/index.js
  warnMissingPluginDirective("Collapse", "collapse", "collapse");
  warnMissingPluginDirective("Intersect", "intersect", "intersect");
  warnMissingPluginDirective("Focus", "trap", "focus");
  warnMissingPluginDirective("Mask", "mask", "mask");
  function warnMissingPluginDirective(name, directiveName, slug) {
    directive(directiveName, (el) => warn(`You can't use [x-${directiveName}] without first installing the "${name}" plugin here: https://alpinejs.dev/plugins/${slug}`, el));
  }

  // packages/alpinejs/src/index.js
  alpine_default.setEvaluator(normalEvaluator);
  alpine_default.setReactivityEngine({ reactive: reactive2, effect: effect2, release: stop, raw: toRaw });
  var src_default = alpine_default;

  // packages/alpinejs/builds/module.js
  var module_default = src_default;

  // Entry point for the Castle Components project.

  // Alpine plugins.
  module_default.plugin([module_default$5, module_default$4, module_default$3, module_default$2, module_default$1]);

  document.addEventListener('alpine:init', () => {
    // Stores
    module_default.store('theme', {
      mode: module_default.$persist(''),
      themes: ['light', 'dark'],
      setMode(value) {
        if (this.themes.includes(value)) {
          this.mode = value;
          document.documentElement.classList.remove(...this.themes);
          document.documentElement.classList.add(value);
        }
      },
    });
  });
  window.Alpine = module_default;
  window.Alpine.start();

})();
//# sourceMappingURL=castle.min.js.map
